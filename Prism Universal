local PRISM = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = game.Workspace.CurrentCamera
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")
local TeleportService = game:GetService("TeleportService")
local Debris = game:GetService("Debris")

local Window = PRISM:CreateWindow({
   Name = "🔥 Prism | Universal 🔫",
   LoadingTitle = "🔫 Universal Script 💥",
   LoadingSubtitle = "By kronnixau",
   ConfigurationSaving = {
      Enabled = true,
      FolderName = "PrismHub",
      FileName = "Config"
   },
   Discord = {
      Enabled = false,
      Invite = "gcjaDpMYce",
      RememberJoins = true
   },
   KeySystem = false,
   KeySettings = {
      Title = "Key | Prism Universal",
      Subtitle = "UI Keybind",
      Note = "Key In Discord Server",
      FileName = "Prism",
      SaveKey = true,
      GrabKeyFromSite = true,
      Key = {"https://pastebin.com/XFfbRsjP"}
   }
})

-- Home Tab
local HomeTab = Window:CreateTab("🏠 Home", nil)
local MainSection = HomeTab:CreateSection("Main")

PRISM:Notify({
   Title = "Welcome to Prism Universal",
   Content = "GUI loaded! Use tabs to access features.",
   Duration = 5,
   Image = 13047715178,
   Actions = {
      Ignore = {
         Name = "Okay!",
         Callback = function()
            print("The user tapped Okay!")
         end
      }
   }
})

local WelcomeLabel = HomeTab:CreateLabel("Welcome to Prism Universal! Use the tabs to access all features.")

-- Fly Functionality
_G.flyEnabled = false
local flySpeed = 200
local bodyVelocity, bodyGyro = nil, nil
local flyConnections = {}

local function startFly()
    local player = Players.LocalPlayer
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end

    local humanoidRootPart = character.HumanoidRootPart
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.PlatformStand = true
        humanoid.WalkSpeed = 0
    end

    -- Lift player slightly with tween for smoothness
    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = TweenService:Create(humanoidRootPart, tweenInfo, {CFrame = humanoidRootPart.CFrame + Vector3.new(0, 5, 0)})
    tween:Play()

    -- Create BodyGyro for rotation
    bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bodyGyro.P = 9e4
    bodyGyro.CFrame = Camera.CFrame
    bodyGyro.Parent = humanoidRootPart

    -- Create BodyVelocity for movement
    bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = humanoidRootPart

    -- Movement controls
    local keys = {Forward = 0, Backward = 0, Left = 0, Right = 0, Up = 0, Down = 0}
    
    flyConnections.inputBegan = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.W then keys.Forward = 1 end
        if input.KeyCode == Enum.KeyCode.S then keys.Backward = -1 end
        if input.KeyCode == Enum.KeyCode.A then keys.Left = -1 end
        if input.KeyCode == Enum.KeyCode.D then keys.Right = 1 end
        if input.KeyCode == Enum.KeyCode.Space then keys.Up = 1 end
        if input.KeyCode == Enum.KeyCode.LeftShift then keys.Down = -1 end
    end)

    flyConnections.inputEnded = UserInputService.InputEnded:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.W then keys.Forward = 0 end
        if input.KeyCode == Enum.KeyCode.S then keys.Backward = 0 end
        if input.KeyCode == Enum.KeyCode.A then keys.Left = 0 end
        if input.KeyCode == Enum.KeyCode.D then keys.Right = 0 end
        if input.KeyCode == Enum.KeyCode.Space then keys.Up = 0 end
        if input.KeyCode == Enum.KeyCode.LeftShift then keys.Down = 0 end
    end)

    flyConnections.render = RunService.RenderStepped:Connect(function(delta)
        if _G.flyEnabled and bodyGyro and bodyVelocity then
            bodyGyro.CFrame = Camera.CFrame
            local moveDirection = Vector3.new(keys.Left + keys.Right, keys.Up + keys.Down, keys.Backward + keys.Forward)
            if moveDirection.Magnitude > 0 then
                local velocity = (Camera.CFrame * CFrame.new(moveDirection)).Position - humanoidRootPart.Position
                bodyVelocity.Velocity = velocity.Unit * flySpeed
            else
                bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            end
        end
    end)
end

local function stopFly()
    local player = Players.LocalPlayer
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.PlatformStand = false
            humanoid.WalkSpeed = 16
        end
    end
    if bodyVelocity then
        bodyVelocity:Destroy()
        bodyVelocity = nil
    end
    if bodyGyro then
        bodyGyro:Destroy()
        bodyGyro = nil
    end
    for _, conn in pairs(flyConnections) do
        conn:Disconnect()
    end
    flyConnections = {}
end

local function toggleFly()
    _G.flyEnabled = not _G.flyEnabled
    if _G.flyEnabled then
        startFly()
        PRISM:Notify({
            Title = "Fly",
            Content = "Flying enabled! Use WASD, Space (up), Shift (down).",
            Duration = 3,
            Image = 13047715178
        })
    else
        stopFly()
        PRISM:Notify({
            Title = "Fly",
            Content = "Flying disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

-- Noclip Functionality
_G.noclipEnabled = false
local noclipConnection

local function setCollision(state)
    local character = Players.LocalPlayer.Character
    if not character then return end
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = state
        end
    end
end

local function startNoclip()
    _G.noclipEnabled = true
    setCollision(false)
    noclipConnection = RunService.Stepped:Connect(function()
        if _G.noclipEnabled then
            -- Minimal check, no full loop every frame
            local character = Players.LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0) -- Prevent falling if needed
            end
        end
    end)
    PRISM:Notify({
        Title = "Noclip",
        Content = "Noclip enabled! You can pass through objects.",
        Duration = 3,
        Image = 13047715178
    })
end

local function stopNoclip()
    _G.noclipEnabled = false
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
    end
    setCollision(true)
    PRISM:Notify({
        Title = "Noclip",
        Content = "Noclip disabled!",
        Duration = 3,
        Image = 13047715178
    })
end

-- Keybinds
local keybinds = {
    fly = Enum.KeyCode.F,
    noclip = Enum.KeyCode.G,
    interact = Enum.KeyCode.E
}

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == keybinds.fly then
        toggleFly()
    elseif input.KeyCode == keybinds.noclip then
        if _G.noclipEnabled then
            stopNoclip()
        else
            startNoclip()
        end
    elseif input.KeyCode == keybinds.interact then
        triggerInteraction()
    end
end)

-- Instance Interaction
local interactDistance = 10
local interactHighlightColor = Color3.fromRGB(255, 255, 0)
local interactableParts = {}
local interactConnection

local function isInteractable(part)
    return part:IsA("BasePart") and (part:FindFirstChild("ClickDetector") or part:FindFirstChild("ProximityPrompt") or part.Name:lower():match("door") or part.Name:lower():match("button"))
end

local function highlightInteractable(part)
    if not interactableParts[part] then
        local highlight = Instance.new("Highlight")
        highlight.Name = "InteractHighlight"
        highlight.Adornee = part
        highlight.FillColor = interactHighlightColor
        highlight.OutlineColor = interactHighlightColor
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.Parent = part
        interactableParts[part] = highlight
    end
end

local function removeHighlight(part)
    if interactableParts[part] then
        interactableParts[part]:Destroy()
        interactableParts[part] = nil
    end
end

local function triggerInteraction()
    local player = Players.LocalPlayer
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local root = character.HumanoidRootPart
    local closestPart = nil
    local closestDist = interactDistance
    for part, _ in pairs(interactableParts) do
        local dist = (part.Position - root.Position).Magnitude
        if dist <= closestDist then
            closestDist = dist
            closestPart = part
        end
    end
    if closestPart then
        if closestPart:FindFirstChild("ClickDetector") then
            fireclickdetector(closestPart.ClickDetector)
        elseif closestPart:FindFirstChild("ProximityPrompt") then
            fireproximityprompt(closestPart.ProximityPrompt)
        elseif closestPart:IsA("BasePart") then
            pcall(function() closestPart:Activate() end)
        end
        PRISM:Notify({
            Title = "Interaction",
            Content = "Interacted with " .. closestPart.Name,
            Duration = 3,
            Image = 13047715178
        })
    end
end

local function updateInteractables()
    local player = Players.LocalPlayer
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local root = character.HumanoidRootPart
    local region = Region3.new(root.Position - Vector3.new(interactDistance, interactDistance, interactDistance), root.Position + Vector3.new(interactDistance, interactDistance, interactDistance))
    local parts = workspace:FindPartsInRegion3(region, character, 100) -- Limit to 100 parts for performance
    for _, part in pairs(parts) do
        if isInteractable(part) then
            highlightInteractable(part)
        else
            removeHighlight(part)
        end
    end
    -- Clean up old highlights not in range
    for part, _ in pairs(interactableParts) do
        if (part.Position - root.Position).Magnitude > interactDistance then
            removeHighlight(part)
        end
    end
end

-- Kill All
local function killAll()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = player.Character.Humanoid
            pcall(function() humanoid.Health = 0 end)
            if player.Character:FindFirstChild("HumanoidRootPart") then
                local bv = Instance.new("BodyVelocity")
                bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
                bv.Velocity = Vector3.new(0, -1000, 0)
                bv.Parent = player.Character.HumanoidRootPart
                Debris:AddItem(bv, 0.1)
            end
            for _, remote in pairs(ReplicatedStorage:GetDescendants()) do
                if remote:IsA("RemoteEvent") and (remote.Name:lower():match("damage") or remote.Name:lower():match("hit")) then
                    pcall(function()
                        remote:FireServer(player.Character.Humanoid, math.huge)
                    end)
                end
            end
        end
    end
    PRISM:Notify({
        Title = "Kill All",
        Content = "Attempted to kill all players!",
        Duration = 3,
        Image = 13047715178
    })
end

-- Home Tab Features
local FlyQuickToggle = HomeTab:CreateToggle({
   Name = "Quick Toggle Fly",
   CurrentValue = false,
   Flag = "quickfly",
   Callback = function(Value)
       toggleFly()
   end,
})

local NoclipQuickToggle = HomeTab:CreateToggle({
   Name = "Quick Toggle Noclip",
   CurrentValue = false,
   Flag = "quicknoclip",
   Callback = function(Value)
       if Value then
           startNoclip()
       else
           stopNoclip()
       end
   end,
})

local KillAllQuickButton = HomeTab:CreateButton({
   Name = "Quick Kill All",
   Callback = function()
       killAll()
   end,
})

local ConfigLabel = HomeTab:CreateLabel("Configurations are automatically saved and loaded from PrismHub/Config.json")

-- Movement Tab
local MovementTab = Window:CreateTab("🏃 Movement", nil)
local MovementSection = MovementTab:CreateSection("Options")

local FlyButton = MovementTab:CreateButton({
   Name = "Toggle Fly",
   Callback = function()
       toggleFly()
   end,
})

local FlySpeedSlider = MovementTab:CreateSlider({
   Name = "Fly Speed",
   Range = {10, 1000},
   Increment = 10,
   Suffix = "Speed",
   CurrentValue = 200,
   Flag = "flyspeed",
   Callback = function(Value)
       flySpeed = Value
   end,
})

local NoclipButton = MovementTab:CreateButton({
   Name = "Toggle Noclip",
   Callback = function()
       if _G.noclipEnabled then
           stopNoclip()
       else
           startNoclip()
       end
   end,
})

local SpeedHackSlider = MovementTab:CreateSlider({
   Name = "Speed Hack",
   Range = {16, 500},
   Increment = 1,
   Suffix = "Speed",
   CurrentValue = 16,
   Flag = "speedhack",
   Callback = function(Value)
       local character = Players.LocalPlayer.Character
       if character then
           local humanoid = character:FindFirstChildOfClass("Humanoid")
           if humanoid then
               humanoid.WalkSpeed = Value
           end
       end
   end,
})

local JumpHackSlider = MovementTab:CreateSlider({
   Name = "Jump Hack",
   Range = {50, 500},
   Increment = 1,
   Suffix = "Power",
   CurrentValue = 50,
   Flag = "jumphack",
   Callback = function(Value)
       local character = Players.LocalPlayer.Character
       if character then
           local humanoid = character:FindFirstChildOfClass("Humanoid")
           if humanoid then
               humanoid.JumpPower = Value
           end
       end
   end,
})

local AntiAimToggle = MovementTab:CreateToggle({
   Name = "Anti-Aim",
   CurrentValue = false,
   Flag = "antiaim",
   Callback = function(Value)
       _G.antiAimEnabled = Value
       if Value then
           RunService:BindToRenderStep("AntiAim", Enum.RenderPriority.Camera.Value + 1, function()
               local character = Players.LocalPlayer.Character
               if character and character:FindFirstChild("HumanoidRootPart") then
                   character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(math.random(-180, 180)), 0)
               end
           end)
       else
           RunService:UnbindFromRenderStep("AntiAim")
       end
   end,
})

local BunnyHopToggle = MovementTab:CreateToggle({
   Name = "Bunny Hop",
   CurrentValue = false,
   Flag = "bunnyhop",
   Callback = function(Value)
       _G.bunnyHopEnabled = Value
       if Value then
           RunService:BindToRenderStep("BunnyHop", Enum.RenderPriority.Input.Value, function()
               local character = Players.LocalPlayer.Character
               if character and character:FindFirstChildOfClass("Humanoid") then
                   local humanoid = character.Humanoid
                   if humanoid:GetState() == Enum.HumanoidStateType.Freefall and UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                       humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                   end
               end
           end)
       else
           RunService:UnbindFromRenderStep("BunnyHop")
       end
   end,
})

local InfiniteJumpToggle = MovementTab:CreateToggle({
   Name = "Infinite Jump",
   CurrentValue = false,
   Flag = "infinitejump",
   Callback = function(Value)
       _G.infiniteJumpEnabled = Value
       if Value then
           UserInputService.JumpRequest:Connect(function()
               if _G.infiniteJumpEnabled then
                   local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                   if humanoid then
                       humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                   end
               end
           end)
       end
   end,
})

local AirWalkToggle = MovementTab:CreateToggle({
   Name = "Air Walk",
   CurrentValue = false,
   Flag = "airwalk",
   Callback = function(Value)
       _G.airWalkEnabled = Value
       local platform = Instance.new("Part")
       platform.Size = Vector3.new(5, 1, 5)
       platform.Transparency = 1
       platform.Anchored = true
       platform.Parent = workspace
       if Value then
           RunService:BindToRenderStep("AirWalk", Enum.RenderPriority.Character.Value, function()
               local character = Players.LocalPlayer.Character
               if character and character:FindFirstChild("HumanoidRootPart") then
                   platform.CFrame = character.HumanoidRootPart.CFrame - Vector3.new(0, 3, 0)
               end
           end)
       else
           RunService:UnbindFromRenderStep("AirWalk")
           platform:Destroy()
       end
   end,
})

local SpiderClimbToggle = MovementTab:CreateToggle({
   Name = "Spider Climb",
   CurrentValue = false,
   Flag = "spiderclimb",
   Callback = function(Value)
       _G.spiderClimbEnabled = Value
       if Value then
           RunService:BindToRenderStep("SpiderClimb", Enum.RenderPriority.Input.Value, function()
               local character = Players.LocalPlayer.Character
               if character and character:FindFirstChild("HumanoidRootPart") and UserInputService:IsKeyDown(Enum.KeyCode.W) then
                   local ray = Ray.new(character.HumanoidRootPart.Position, character.HumanoidRootPart.CFrame.LookVector * 2)
                   local hit, pos, normal = workspace:FindPartOnRay(ray, character)
                   if hit then
                       character.HumanoidRootPart.Velocity = normal * 50
                   end
               end
           end)
       else
           RunService:UnbindFromRenderStep("SpiderClimb")
       end
   end,
})

local function getPlayerNames()
    local names = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            table.insert(names, player.Name)
        end
    end
    return names
end

local TeleportDropdown = MovementTab:CreateDropdown({
   Name = "Teleport to Player",
   Options = getPlayerNames(),
   CurrentOption = {""},
   MultipleOptions = false,
   Flag = "teleportplayer",
   Callback = function(Option)
       local targetPlayer = Players:FindFirstChild(Option[1])
       if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
           local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Linear)
           local tween = TweenService:Create(Players.LocalPlayer.Character.HumanoidRootPart, tweenInfo, {CFrame = targetPlayer.Character.HumanoidRootPart.CFrame})
           tween:Play()
           PRISM:Notify({
               Title = "Teleport",
               Content = "Teleported to " .. targetPlayer.Name,
               Duration = 3,
               Image = 13047715178
           })
       end
   end
})

Players.PlayerAdded:Connect(function()
    TeleportDropdown:Set(getPlayerNames())
end)
Players.PlayerRemoving:Connect(function()
    TeleportDropdown:Set(getPlayerNames())
end)

-- Visuals Tab
local VisualsTab = Window:CreateTab("🎨 Visuals", nil)
local VisualsSection = VisualsTab:CreateSection("Options")

local espFeatures = {
    box = false,
    name = false,
    distance = false,
    health = false,
    tracers = false,
    teamFilter = false,
    textOutline = true,
    useTeamColors = false,
    skeleton = false,
    item = false
}
local espColors = {
    box = Color3.fromRGB(255, 255, 255),
    text = Color3.fromRGB(255, 255, 255),
    tracer = Color3.fromRGB(255, 255, 255),
    skeleton = Color3.fromRGB(255, 255, 255),
    item = Color3.fromRGB(0, 255, 0)
}
local playerESP = {}
local itemESP = {}

local function shouldShowESP(player)
    if player == Players.LocalPlayer then return false end
    if espFeatures.teamFilter and player.Team == Players.LocalPlayer.Team then return false end
    return true
end

local function getESPColor(player)
    return espFeatures.useTeamColors and player.Team and player.TeamColor.Color or nil
end

local function createBox(player)
    if not shouldShowESP(player) or not player.Character then return end
    local box = Instance.new("SelectionBox")
    box.Name = "ESPBox"
    box.Adornee = player.Character
    box.Color3 = getESPColor(player) or espColors.box
    box.LineThickness = 0.05
    box.SurfaceTransparency = 1
    box.Parent = player.Character
    if not playerESP[player] then playerESP[player] = {} end
    playerESP[player].box = box
end

local function createTextESP(player)
    if not shouldShowESP(player) or not player.Character or not player.Character:FindFirstChild("Head") then return end
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESPText"
    billboard.Adornee = player.Character.Head
    billboard.Size = UDim2.new(0, 200, 0, 100)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    local text = Instance.new("TextLabel")
    text.Size = UDim2.new(1, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.TextColor3 = getESPColor(player) or espColors.text
    text.TextSize = 14
    text.TextStrokeTransparency = espFeatures.textOutline and 0 or 1
    text.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    text.TextYAlignment = Enum.TextYAlignment.Top
    text.Parent = billboard
    billboard.Parent = player.Character.Head
    if not playerESP[player] then playerESP[player] = {} end
    playerESP[player].text = {gui = billboard, label = text}
end

local function updateTextESP(player)
    if playerESP[player] and playerESP[player].text and player.Character then
        local lines = {}
        if espFeatures.name then
            table.insert(lines, player.Name)
        end
        if espFeatures.distance then
            local dist = math.floor((Players.LocalPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude)
            table.insert(lines, dist .. " studs")
        end
        if espFeatures.health then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                table.insert(lines, math.floor(humanoid.Health) .. "/" .. humanoid.MaxHealth)
            end
        end
        playerESP[player].text.label.Text = table.concat(lines, "\n")
        playerESP[player].text.label.TextStrokeTransparency = espFeatures.textOutline and 0 or 1
        playerESP[player].text.label.TextColor3 = getESPColor(player) or espColors.text
    end
end

local function createTracer(player)
    if not shouldShowESP(player) or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    local tracer = Drawing.new("Line")
    tracer.Visible = false
    tracer.Color = getESPColor(player) or espColors.tracer
    tracer.Thickness = 1
    tracer.Transparency = 1
    if not playerESP[player] then playerESP[player] = {} end
    playerESP[player].tracer = tracer
end

local function updateTracer(player)
    if playerESP[player] and playerESP[player].tracer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local tracer = playerESP[player].tracer
        local targetPos = player.Character.HumanoidRootPart.Position
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
        local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
        tracer.From = center
        tracer.To = Vector2.new(screenPos.X, screenPos.Y)
        tracer.Color = getESPColor(player) or espColors.tracer
        tracer.Visible = onScreen
    end
end

local function createSkeleton(player)
    if not shouldShowESP(player) or not player.Character then return end
    local skeletonLines = {}
    local parts = {"Head", "UpperTorso", "LowerTorso", "LeftUpperArm", "RightUpperArm", "LeftLowerArm", "RightLowerArm", "LeftHand", "RightHand", "LeftUpperLeg", "RightUpperLeg", "LeftLowerLeg", "RightLowerLeg", "LeftFoot", "RightFoot"}
    for _, partName in pairs(parts) do
        if player.Character:FindFirstChild(partName) then
            local line = Drawing.new("Line")
            line.Visible = false
            line.Color = getESPColor(player) or espColors.skeleton
            line.Thickness = 1
            line.Transparency = 1
            skeletonLines[partName] = line
        end
    end
    if not playerESP[player] then playerESP[player] = {} end
    playerESP[player].skeleton = skeletonLines
end

local function updateSkeleton(player)
    if playerESP[player] and playerESP[player].skeleton and player.Character then
        local connections = {
            Head = "UpperTorso",
            UpperTorso = "LowerTorso",
            UpperTorso = "LeftUpperArm",
            UpperTorso = "RightUpperArm",
            LeftUpperArm = "LeftLowerArm",
            RightUpperArm = "RightLowerArm",
            LeftLowerArm = "LeftHand",
            RightLowerArm = "RightHand",
            LowerTorso = "LeftUpperLeg",
            LowerTorso = "RightUpperLeg",
            LeftUpperLeg = "LeftLowerLeg",
            RightUpperLeg = "RightLowerLeg",
            LeftLowerLeg = "LeftFoot",
            RightLowerLeg = "RightFoot"
        }
        for fromPart, toPart in pairs(connections) do
            if player.Character:FindFirstChild(fromPart) and player.Character:FindFirstChild(toPart) then
                local fromPos = Camera:WorldToViewportPoint(player.Character[fromPart].Position)
                local toPos = Camera:WorldToViewportPoint(player.Character[toPart].Position)
                local line = playerESP[player].skeleton[fromPart] or playerESP[player].skeleton[toPart]
                if line then
                    line.From = Vector2.new(fromPos.X, fromPos.Y)
                    line.To = Vector2.new(toPos.X, toPos.Y)
                    line.Visible = fromPos.Z > 0 and toPos.Z > 0
                end
            end
        end
    end
end

local function createItemESP(item)
    if not item:IsA("BasePart") or itemESP[item] then return end
    local highlight = Instance.new("Highlight")
    highlight.Name = "ItemESP"
    highlight.Adornee = item
    highlight.FillColor = espColors.item
    highlight.OutlineColor = espColors.item
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.Parent = item
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ItemText"
    billboard.Adornee = item
    billboard.Size = UDim2.new(0, 100, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 2, 0)
    billboard.AlwaysOnTop = true
    local text = Instance.new("TextLabel")
    text.Size = UDim2.new(1, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.TextColor3 = espColors.text
    text.TextSize = 12
    text.Text = item.Name
    text.Parent = billboard
    billboard.Parent = item
    itemESP[item] = {highlight = highlight, billboard = billboard}
end

local function removeItemESP(item)
    if itemESP[item] then
        itemESP[item].highlight:Destroy()
        itemESP[item].billboard:Destroy()
        itemESP[item] = nil
    end
end

local function toggleESPFeature(feature)
    espFeatures[feature] = not espFeatures[feature]
    if espFeatures[feature] then
        if feature == "item" then
            for _, item in pairs(workspace:GetDescendants()) do
                if item:IsA("BasePart") and item.Name:lower():match("item") or item.Name:lower():match("tool") then
                    createItemESP(item)
                end
            end
            workspace.DescendantAdded:Connect(function(item)
                if espFeatures.item and item:IsA("BasePart") and item.Name:lower():match("item") or item.Name:lower():match("tool") then
                    createItemESP(item)
                end
            end)
            workspace.DescendantRemoving:Connect(function(item)
                removeItemESP(item)
            end)
        else
            for _, player in pairs(Players:GetPlayers()) do
                if shouldShowESP(player) then
                    if feature == "box" then createBox(player) end
                    if feature == "tracers" then createTracer(player) end
                    if feature == "skeleton" then createSkeleton(player) end
                    if feature == "name" or feature == "distance" or feature == "health" then
                        if not playerESP[player] or not playerESP[player].text then
                            createTextESP(player)
                        end
                        updateTextESP(player)
                    end
                end
            end
        end
        PRISM:Notify({
            Title = "ESP",
            Content = feature:gsub("^%l", string.upper) .. " enabled!",
            Duration = 3,
            Image = 13047715178
        })
    else
        if feature == "item" then
            for item, _ in pairs(itemESP) do
                removeItemESP(item)
            end
        else
            for _, player in pairs(Players:GetPlayers()) do
                if feature == "box" then removeESPFeature(player, "box") end
                if feature == "tracers" then removeESPFeature(player, "tracer") end
                if feature == "skeleton" then
                    if playerESP[player] and playerESP[player].skeleton then
                        for _, line in pairs(playerESP[player].skeleton) do
                            line:Remove()
                        end
                        playerESP[player].skeleton = nil
                    end
                end
                if feature == "name" or feature == "distance" or feature == "health" then
                    updateTextESP(player)
                    if not espFeatures.name and not espFeatures.distance and not espFeatures.health then
                        removeESPFeature(player, "text")
                    end
                end
            end
        end
        PRISM:Notify({
            Title = "ESP",
            Content = feature:gsub("^%l", string.upper) .. " disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

local function removeESPFeature(player, feature)
    if playerESP[player] and playerESP[player][feature] then
        if playerESP[player][feature].Destroy then
            playerESP[player][feature]:Destroy()
        elseif playerESP[player][feature].Remove then
            playerESP[player][feature]:Remove()
        end
        playerESP[player][feature] = nil
    end
end

local function updateTextOutline()
    for _, player in pairs(Players:GetPlayers()) do
        if playerESP[player] and playerESP[player].text then
            playerESP[player].text.label.TextStrokeTransparency = espFeatures.textOutline and 0 or 1
        end
    end
end

RunService.RenderStepped:Connect(function()
    for _, player in pairs(Players:GetPlayers()) do
        if espFeatures.distance or espFeatures.health or espFeatures.name then updateTextESP(player) end
        if espFeatures.tracers then updateTracer(player) end
        if espFeatures.skeleton then updateSkeleton(player) end
    end
    updateInteractables()
end)

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        if shouldShowESP(player) then
            if espFeatures.box then createBox(player) end
            if espFeatures.tracers then createTracer(player) end
            if espFeatures.skeleton then createSkeleton(player) end
            if espFeatures.name or espFeatures.distance or espFeatures.health then 
                createTextESP(player)
                updateTextESP(player)
            end
        end
    end)
    player:GetPropertyChangedSignal("Team"):Connect(function()
        for feature in pairs(playerESP[player] or {}) do
            removeESPFeature(player, feature)
        end
        if shouldShowESP(player) then
            if espFeatures.box then createBox(player) end
            if espFeatures.tracers then createTracer(player) end
            if espFeatures.skeleton then createSkeleton(player) end
            if espFeatures.name or espFeatures.distance or espFeatures.health then 
                createTextESP(player)
                updateTextESP(player)
            end
        end
    end)
end)

Players.PlayerRemoving:Connect(function(player)
    if playerESP[player] then
        for feature in pairs(playerESP[player]) do
            removeESPFeature(player, feature)
        end
        playerESP[player] = nil
    end
end)

-- ESP Toggles and Color Pickers
local BoxToggle = VisualsTab:CreateToggle({
   Name = "Box ESP",
   CurrentValue = false,
   Flag = "boxesp",
   Callback = function(Value)
       toggleESPFeature("box")
   end,
})

local BoxColorPicker = VisualsTab:CreateColorPicker({
   Name = "Box Color",
   Color = Color3.fromRGB(255, 255, 255),
   Flag = "boxcolor",
   Callback = function(Color)
       espColors.box = Color
       for player, esp in pairs(playerESP) do
           if esp.box then
               esp.box.Color3 = getESPColor(player) or Color
           end
       end
   end
})

local NameToggle = VisualsTab:CreateToggle({
   Name = "Name ESP",
   CurrentValue = false,
   Flag = "nameesp",
   Callback = function(Value)
       toggleESPFeature("name")
   end,
})

local DistanceToggle = VisualsTab:CreateToggle({
   Name = "Distance ESP",
   CurrentValue = false,
   Flag = "distanceesp",
   Callback = function(Value)
       toggleESPFeature("distance")
   end,
})

local HealthToggle = VisualsTab:CreateToggle({
   Name = "Health ESP",
   CurrentValue = false,
   Flag = "healthesp",
   Callback = function(Value)
       toggleESPFeature("health")
   end,
})

local TextColorPicker = VisualsTab:CreateColorPicker({
   Name = "Text Color",
   Color = Color3.fromRGB(255, 255, 255),
   Flag = "textcolor",
   Callback = function(Color)
       espColors.text = Color
       for player, esp in pairs(playerESP) do
           if esp.text then
               esp.text.label.TextColor3 = getESPColor(player) or Color
           end
       end
   end
})

local TextOutlineToggle = VisualsTab:CreateToggle({
   Name = "Text Outline",
   CurrentValue = true,
   Flag = "textoutline",
   Callback = function(Value)
       espFeatures.textOutline = Value
       updateTextOutline()
   end,
})

local TracersToggle = VisualsTab:CreateToggle({
   Name = "Tracers ESP",
   CurrentValue = false,
   Flag = "tracersesp",
   Callback = function(Value)
       toggleESPFeature("tracers")
   end,
})

local TracerColorPicker = VisualsTab:CreateColorPicker({
   Name = "Tracer Color",
   Color = Color3.fromRGB(255, 255, 255),
   Flag = "tracercolor",
   Callback = function(Color)
       espColors.tracer = Color
       for player, esp in pairs(playerESP) do
           if esp.tracer then
               esp.tracer.Color = getESPColor(player) or Color
           end
       end
   end
})

local SkeletonToggle = VisualsTab:CreateToggle({
   Name = "Skeleton ESP",
   CurrentValue = false,
   Flag = "skeletonesp",
   Callback = function(Value)
       toggleESPFeature("skeleton")
   end,
})

local SkeletonColorPicker = VisualsTab:CreateColorPicker({
   Name = "Skeleton Color",
   Color = Color3.fromRGB(255, 255, 255),
   Flag = "skeletoncolor",
   Callback = function(Color)
       espColors.skeleton = Color
       for player, esp in pairs(playerESP) do
           if esp.skeleton then
               for _, line in pairs(esp.skeleton) do
                   line.Color = getESPColor(player) or Color
               end
           end
       end
   end
})

local ItemESPToggle = VisualsTab:CreateToggle({
   Name = "Item ESP",
   CurrentValue = false,
   Flag = "itemesp",
   Callback = function(Value)
       toggleESPFeature("item")
   end,
})

local ItemColorPicker = VisualsTab:CreateColorPicker({
   Name = "Item Color",
   Color = Color3.fromRGB(0, 255, 0),
   Flag = "itemcolor",
   Callback = function(Color)
       espColors.item = Color
       for _, data in pairs(itemESP) do
           data.highlight.FillColor = Color
           data.highlight.OutlineColor = Color
       end
   end
})

local TeamFilterToggle = VisualsTab:CreateToggle({
   Name = "Team Filter",
   CurrentValue = false,
   Flag = "teamfilter",
   Callback = function(Value)
       espFeatures.teamFilter = Value
       for _, player in pairs(Players:GetPlayers()) do
           for feature in pairs(playerESP[player] or {}) do
               removeESPFeature(player, feature)
           end
           if shouldShowESP(player) then
               if espFeatures.box then createBox(player) end
               if espFeatures.tracers then createTracer(player) end
               if espFeatures.skeleton then createSkeleton(player) end
               if espFeatures.name or espFeatures.distance or espFeatures.health then 
                   createTextESP(player)
                   updateTextESP(player)
               end
           end
       end
   end,
})

local UseTeamColorsToggle = VisualsTab:CreateToggle({
   Name = "Use Team Colors",
   CurrentValue = false,
   Flag = "useteamcolors",
   Callback = function(Value)
       espFeatures.useTeamColors = Value
       for _, player in pairs(Players:GetPlayers()) do
           if playerESP[player] then
               if playerESP[player].box then
                   playerESP[player].box.Color3 = getESPColor(player) or espColors.box
               end
               if playerESP[player].text then
                   playerESP[player].text.label.TextColor3 = getESPColor(player) or espColors.text
               end
               if playerESP[player].tracer then
                   playerESP[player].tracer.Color = getESPColor(player) or espColors.tracer
               end
               if playerESP[player].skeleton then
                   for _, line in pairs(playerESP[player].skeleton) do
                       line.Color = getESPColor(player) or espColors.skeleton
                   end
               end
           end
       end
   end,
})

local FullbrightToggle = VisualsTab:CreateToggle({
   Name = "Fullbright",
   CurrentValue = false,
   Flag = "fullbright",
   Callback = function(Value)
       if Value then
           Lighting.Brightness = 2
           Lighting.GlobalShadows = false
           Lighting.FogEnd = 9e9
       else
           Lighting.Brightness = 1
           Lighting.GlobalShadows = true
           Lighting.FogEnd = 1000
       end
   end,
})

local ChamsToggle = VisualsTab:CreateToggle({
   Name = "Chams",
   CurrentValue = false,
   Flag = "chams",
   Callback = function(Value)
       for _, player in pairs(Players:GetPlayers()) do
           if player ~= Players.LocalPlayer and player.Character then
               for _, part in pairs(player.Character:GetDescendants()) do
                   if part:IsA("BasePart") then
                       local highlight = part:FindFirstChild("ChamsHighlight")
                       if Value and not highlight then
                           highlight = Instance.new("Highlight")
                           highlight.Name = "ChamsHighlight"
                           highlight.FillColor = getESPColor(player) or espColors.box
                           highlight.OutlineColor = Color3.fromRGB(0, 0, 0)
                           highlight.FillTransparency = 0.5
                           highlight.Parent = part
                       elseif not Value and highlight then
                           highlight:Destroy()
                       end
                   end
               end
           end
       end
   end,
})

local CrosshairToggle = VisualsTab:CreateToggle({
   Name = "Custom Crosshair",
   CurrentValue = false,
   Flag = "crosshair",
   Callback = function(Value)
       local crosshair = Drawing.new("Circle")
       crosshair.Visible = Value
       crosshair.Color = Color3.fromRGB(255, 0, 0)
       crosshair.Thickness = 1
       crosshair.NumSides = 100
       crosshair.Radius = 5
       crosshair.Filled = true
       crosshair.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
       if Value then
           RunService:BindToRenderStep("Crosshair", Enum.RenderPriority.Camera.Value, function()
               crosshair.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
           end)
       else
           RunService:UnbindFromRenderStep("Crosshair")
           crosshair:Remove()
       end
   end,
})

local FOVChangerSlider = VisualsTab:CreateSlider({
   Name = "FOV Changer",
   Range = {30, 120},
   Increment = 1,
   Suffix = "Degrees",
   CurrentValue = 70,
   Flag = "fovchanger",
   Callback = function(Value)
       Camera.FieldOfView = Value
   end,
})

local XRayToggle = VisualsTab:CreateToggle({
   Name = "X-Ray (Transparent Walls)",
   CurrentValue = false,
   Flag = "xray",
   Callback = function(Value)
       for _, part in pairs(workspace:GetDescendants()) do
           if part:IsA("BasePart") and not part.Parent:FindFirstChildOfClass("Humanoid") then
               part.Transparency = Value and 0.5 or 0
           end
       end
   end,
})

-- Combat Tab
local CombatTab = Window:CreateTab("🔫 Combat", nil)
local CombatSection = CombatTab:CreateSection("Options")

local aimbotEnabled = false
local aimbotTargetPart = "Head"
local aimbotFOV = 200
local aimbotSmoothness = 0.5
local aimbotVisibleCheck = false
local aimbotTeamFilter = false
local aimbotKey = Enum.UserInputType.MouseButton2
local aimbotConnection
local showFOV = false
local fovCircle = Drawing.new("Circle")
fovCircle.Visible = false
fovCircle.Thickness = 1
fovCircle.NumSides = 100
fovCircle.Radius = aimbotFOV
fovCircle.Color = Color3.fromRGB(255, 0, 0)
fovCircle.Filled = false
fovCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
local fovColor = Color3.fromRGB(255, 0, 0)

local function updateFOVCircle()
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    fovCircle.Radius = aimbotFOV
    fovCircle.Color = fovColor
    fovCircle.Visible = showFOV
end

RunService.RenderStepped:Connect(updateFOVCircle)

local function getClosestPlayerInFOV()
    local localPlayer = Players.LocalPlayer
    local localChar = localPlayer.Character
    if not localChar or not localChar:FindFirstChild("Head") then return nil end

    local closestPlayer = nil
    local closestDistance = aimbotFOV
    local center = Camera.ViewportSize / 2

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and (not aimbotTeamFilter or player.Team ~= localPlayer.Team) and player.Character and player.Character:FindFirstChild(aimbotTargetPart) and player.Character:FindFirstChildOfClass("Humanoid") and player.Character.Humanoid.Health > 0 then
            local targetPos = player.Character[aimbotTargetPart].Position
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
            if onScreen then
                local distance = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                if distance < closestDistance and (not aimbotVisibleCheck or onScreen) then
                    closestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end

    return closestPlayer
end

local function toggleAimbot(value)
    aimbotEnabled = value
    if aimbotEnabled then
        aimbotConnection = RunService.RenderStepped:Connect(function()
            if UserInputService:IsMouseButtonPressed(aimbotKey) then
                local target = getClosestPlayerInFOV()
                if target and target.Character and target.Character:FindFirstChild(aimbotTargetPart) then
                    local targetPos = target.Character[aimbotTargetPart].Position
                    local newCFrame = CFrame.lookAt(Camera.CFrame.Position, targetPos)
                    Camera.CFrame = Camera.CFrame:Lerp(newCFrame, aimbotSmoothness)
                end
            end
        end)
        PRISM:Notify({
            Title = "Aimbot",
            Content = "Aimbot enabled! Hold right mouse to aim.",
            Duration = 3,
            Image = 13047715178
        })
    else
        if aimbotConnection then
            aimbotConnection:Disconnect()
            aimbotConnection = nil
        end
        PRISM:Notify({
            Title = "Aimbot",
            Content = "Aimbot disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

local triggerbotEnabled = false
local triggerbotConnection

local function toggleTriggerbot(value)
    triggerbotEnabled = value
    if triggerbotEnabled then
        triggerbotConnection = RunService.RenderStepped:Connect(function()
            local target = getClosestPlayerInFOV()
            if target and target.Character and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
                local tool = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
                if tool then
                    tool:Activate()
                end
            end
        end)
    else
        if triggerbotConnection then
            triggerbotConnection:Disconnect()
            triggerbotConnection = nil
        end
    end
end

local autoHeadshotEnabled = false
local autoHeadshotConnection

local function toggleAutoHeadshot(value)
    autoHeadshotEnabled = value
    if autoHeadshotEnabled then
        autoHeadshotConnection = RunService.RenderStepped:Connect(function()
            local target = getClosestPlayerInFOV()
            if target and target.Character and target.Character:FindFirstChild("Head") then
                local headPos = target.Character.Head.Position
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, headPos)
            end
        end)
    else
        if autoHeadshotConnection then
            autoHeadshotConnection:Disconnect()
            autoHeadshotConnection = nil
        end
    end
end

local silentAimEnabled = false
local silentAimConnection

local function toggleSilentAim(value)
    silentAimEnabled = value
    if silentAimEnabled then
        silentAimConnection = RunService.RenderStepped:Connect(function()
            local target = getClosestPlayerInFOV()
            if target and target.Character and target.Character:FindFirstChild(aimbotTargetPart) then
                local tool = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
                if tool then
                    local handle = tool:FindFirstChild("Handle")
                    if handle then
                        handle.CFrame = CFrame.new(handle.Position, target.Character[aimbotTargetPart].Position)
                    end
                end
            end
        end)
    else
        if silentAimConnection then
            silentAimConnection:Disconnect()
            silentAimConnection = nil
        end
    end
end

local hitboxExpanderEnabled = false
local hitboxSize = 5
local hitboxTransparency = 0.5

local function toggleHitboxExpander(value)
    hitboxExpanderEnabled = value
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local root = player.Character.HumanoidRootPart
            root.Size = value and Vector3.new(hitboxSize, hitboxSize, hitboxSize) or Vector3.new(2, 2, 1)
            root.Transparency = value and hitboxTransparency or 0
            root.CanCollide = false
        end
    end
end

local rapidFireEnabled = false

local function toggleRapidFire(value)
    rapidFireEnabled = value
    if value then
        RunService:BindToRenderStep("RapidFire", Enum.RenderPriority.Input.Value, function()
            local tool = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
            if tool and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
                tool:Activate()
            end
        end)
    else
        RunService:UnbindFromRenderStep("RapidFire")
    end
end

-- Combat Toggles and Options
local AimbotToggle = CombatTab:CreateToggle({
   Name = "Enable Aimbot",
   CurrentValue = false,
   Flag = "aimbotenable",
   Callback = function(Value)
       toggleAimbot(Value)
   end,
})

local TargetPartDropdown = CombatTab:CreateDropdown({
   Name = "Target Part",
   Options = {"Head", "HumanoidRootPart", "Torso"},
   CurrentOption = {"Head"},
   MultipleOptions = false,
   Flag = "targetpart",
   Callback = function(Option)
       aimbotTargetPart = Option[1]
   end,
})

local FOVSlider = CombatTab:CreateSlider({
   Name = "FOV Size",
   Range = {0, 500},
   Increment = 10,
   Suffix = "Radius",
   CurrentValue = 200,
   Flag = "fovsize",
   Callback = function(Value)
       aimbotFOV = Value
   end,
})

local SmoothnessSlider = CombatTab:CreateSlider({
   Name = "Smoothness",
   Range = {0, 1},
   Increment = 0.1,
   Suffix = "Factor",
   CurrentValue = 0.5,
   Flag = "smoothness",
   Callback = function(Value)
       aimbotSmoothness = Value
   end,
})

local VisibleCheckToggle = CombatTab:CreateToggle({
   Name = "Visible Check",
   CurrentValue = false,
   Flag = "visiblecheck",
   Callback = function(Value)
       aimbotVisibleCheck = Value
   end,
})

local AimbotTeamFilterToggle = CombatTab:CreateToggle({
   Name = "Team Filter",
   CurrentValue = false,
   Flag = "aimbotteamfilter",
   Callback = function(Value)
       aimbotTeamFilter = Value
   end,
})

local ShowFOVToggle = CombatTab:CreateToggle({
   Name = "Show FOV Circle",
   CurrentValue = false,
   Flag = "showfov",
   Callback = function(Value)
       showFOV = Value
   end,
})

local FOVColorPicker = CombatTab:CreateColorPicker({
   Name = "FOV Color",
   Color = Color3.fromRGB(255, 0, 0),
   Flag = "fovcolor",
   Callback = function(Color)
       fovColor = Color
   end
})

local TriggerbotToggle = CombatTab:CreateToggle({
   Name = "Triggerbot",
   CurrentValue = false,
   Flag = "triggerbot",
   Callback = function(Value)
       toggleTriggerbot(Value)
   end,
})

local AutoHeadshotToggle = CombatTab:CreateToggle({
   Name = "Auto Headshot",
   CurrentValue = false,
   Flag = "autoheadshot",
   Callback = function(Value)
       toggleAutoHeadshot(Value)
   end,
})

local SilentAimToggle = CombatTab:CreateToggle({
   Name = "Silent Aim",
   CurrentValue = false,
   Flag = "silentaim",
   Callback = function(Value)
       toggleSilentAim(Value)
   end,
})

local HitboxExpanderToggle = CombatTab:CreateToggle({
   Name = "Hitbox Expander",
   CurrentValue = false,
   Flag = "hitboxexpander",
   Callback = function(Value)
       toggleHitboxExpander(Value)
   end,
})

local HitboxSizeSlider = CombatTab:CreateSlider({
   Name = "Hitbox Size",
   Range = {1, 20},
   Increment = 1,
   Suffix = "Size",
   CurrentValue = 5,
   Flag = "hitboxsize",
   Callback = function(Value)
       hitboxSize = Value
       if hitboxExpanderEnabled then
           toggleHitboxExpander(true)
       end
   end,
})

local HitboxTransparencySlider = CombatTab:CreateSlider({
   Name = "Hitbox Transparency",
   Range = {0, 1},
   Increment = 0.1,
   Suffix = "Transparency",
   CurrentValue = 0.5,
   Flag = "hitboxtrans",
   Callback = function(Value)
       hitboxTransparency = Value
       if hitboxExpanderEnabled then
           toggleHitboxExpander(true)
       end
   end,
})

local RapidFireToggle = CombatTab:CreateToggle({
   Name = "Rapid Fire",
   CurrentValue = false,
   Flag = "rapidfire",
   Callback = function(Value)
       toggleRapidFire(Value)
   end,
})

local KillAllButton = CombatTab:CreateButton({
   Name = "Kill All",
   Callback = function()
       killAll()
   end,
})

-- Exploits Tab
local ExploitsTab = Window:CreateTab("💥 Exploits", nil)
local ExploitsSection = ExploitsTab:CreateSection("Options")

local infiniteAmmoEnabled = false
local noRecoilEnabled = false
local noSpreadEnabled = false
local godModeEnabled = false
local antiAFKEnabled = false

local function toggleInfiniteAmmo(value)
    infiniteAmmoEnabled = value
    if value then
        RunService:BindToRenderStep("InfiniteAmmo", Enum.RenderPriority.Character.Value, function()
            local tool = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
            if tool then
                for _, v in pairs(tool:GetDescendants()) do
                    if v:IsA("IntValue") and v.Name:lower():match("ammo") then
                        v.Value = math.huge
                    end
                end
            end
        end)
    else
        RunService:UnbindFromRenderStep("InfiniteAmmo")
    end
end

local function toggleNoRecoil(value)
    noRecoilEnabled = value
    if value then
        RunService:BindToRenderStep("NoRecoil", Enum.RenderPriority.Camera.Value, function()
            local tool = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
            if tool then
                for _, v in pairs(tool:GetDescendants()) do
                    if v:IsA("Vector3Value") and v.Name:lower():match("recoil") then
                        v.Value = Vector3.new(0, 0, 0)
                    end
                end
            end
        end)
    else
        RunService:UnbindFromRenderStep("NoRecoil")
    end
end

local function toggleNoSpread(value)
    noSpreadEnabled = value
    if value then
        RunService:BindToRenderStep("NoSpread", Enum.RenderPriority.Character.Value, function()
            local tool = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
            if tool then
                for _, v in pairs(tool:GetDescendants()) do
                    if v:IsA("NumberValue") and v.Name:lower():match("spread") then
                        v.Value = 0
                    end
                end
            end
        end)
    else
        RunService:UnbindFromRenderStep("NoSpread")
    end
end

local function toggleGodMode(value)
    godModeEnabled = value
    if value then
        RunService:BindToRenderStep("GodMode", Enum.RenderPriority.Character.Value, function()
            local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.Health = humanoid.MaxHealth
            end
        end)
    else
        RunService:UnbindFromRenderStep("GodMode")
    end
end

local function toggleAntiAFK(value)
    antiAFKEnabled = value
    if value then
        Players.LocalPlayer.Idled:Connect(function()
            if antiAFKEnabled then
                game:GetService("VirtualUser"):CaptureController()
                game:GetService("VirtualUser"):ClickButton2(Vector2.new())
            end
        end)
    end
end

local function giveItem(itemName)
    for _, v in pairs(ReplicatedStorage:GetDescendants()) do
        if v:IsA("RemoteEvent") and v.Name:lower():match("give") or v.Name:lower():match("equip") then
            pcall(function()
                v:FireServer(itemName)
            end)
        end
    end
    PRISM:Notify({
        Title = "Give Item",
        Content = "Attempted to give item: " .. itemName,
        Duration = 3,
        Image = 13047715178
    })
end

local function serverCrash()
    local crashTable = {}
    for i = 1, 1000 do
        table.insert(crashTable, string.rep("crash", 1000))
    end
    while true do
        for _, v in pairs(ReplicatedStorage:GetDescendants()) do
            if v:IsA("RemoteEvent") then
                pcall(function()
                    v:FireServer(crashTable)
                end)
            end
        end
        task.wait(0.1) -- Slight delay to reduce lag
    end
end

local InfiniteAmmoToggle = ExploitsTab:CreateToggle({
   Name = "Infinite Ammo",
   CurrentValue = false,
   Flag = "infiniteammo",
   Callback = function(Value)
       toggleInfiniteAmmo(Value)
   end,
})

local NoRecoilToggle = ExploitsTab:CreateToggle({
   Name = "No Recoil",
   CurrentValue = false,
   Flag = "norecoil",
   Callback = function(Value)
       toggleNoRecoil(Value)
   end,
})

local NoSpreadToggle = ExploitsTab:CreateToggle({
   Name = "No Spread",
   CurrentValue = false,
   Flag = "nospread",
   Callback = function(Value)
       toggleNoSpread(Value)
   end,
})

local GodModeToggle = ExploitsTab:CreateToggle({
   Name = "God Mode",
   CurrentValue = false,
   Flag = "godmode",
   Callback = function(Value)
       toggleGodMode(Value)
   end,
})

local AntiAFKToggle = ExploitsTab:CreateToggle({
   Name = "Anti-AFK",
   CurrentValue = false,
   Flag = "antiafk",
   Callback = function(Value)
       toggleAntiAFK(Value)
   end,
})

local GiveItemInput = ExploitsTab:CreateInput({
   Name = "Give Item",
   PlaceholderText = "Enter item name",
   RemoveTextAfterFocusLost = true,
   Callback = function(Text)
       giveItem(Text)
   end,
})

local ServerCrashButton = ExploitsTab:CreateButton({
   Name = "Server Crash (WARNING)",
   Callback = function()
       PRISM:Notify({
           Title = "Server Crash",
           Content = "Attempting to crash server... Use with caution!",
           Duration = 3,
           Image = 13047715178
       })
       spawn(serverCrash)
   end,
})

local ServerHopButton = ExploitsTab:CreateButton({
   Name = "Server Hop",
   Callback = function()
       local servers = HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"))
       local serverId = servers.data[math.random(1, #servers.data)].id
       TeleportService:TeleportToPlaceInstance(game.PlaceId, serverId)
   end,
})

-- Settings Tab
local SettingsTab = Window:CreateTab("⚙️ Settings", nil)
local SettingsSection = SettingsTab:CreateSection("Options")

local FlyKeybind = SettingsTab:CreateKeybind({
   Name = "Fly Keybind",
   CurrentKeybind = "F",
   Flag = "flykeybind",
   Callback = function(Key)
       keybinds.fly = Enum.KeyCode[Key]
   end,
})

local NoclipKeybind = SettingsTab:CreateKeybind({
   Name = "Noclip Keybind",
   CurrentKeybind = "G",
   Flag = "noclipkeybind",
   Callback = function(Key)
       keybinds.noclip = Enum.KeyCode[Key]
   end,
})

local InteractKeybind = SettingsTab:CreateKeybind({
   Name = "Interact Keybind",
   CurrentKeybind = "E",
   Flag = "interactkeybind",
   Callback = function(Key)
       keybinds.interact = Enum.KeyCode[Key]
   end,
})

local InteractDistanceSlider = SettingsTab:CreateSlider({
   Name = "Interact Distance",
   Range = {5, 50},
   Increment = 1,
   Suffix = "Studs",
   CurrentValue = 10,
   Flag = "interactdistance",
   Callback = function(Value)
       interactDistance = Value
   end,
})

local InteractHighlightColorPicker = SettingsTab:CreateColorPicker({
   Name = "Interact Highlight Color",
   Color = Color3.fromRGB(255, 255, 0),
   Flag = "interacthighlightcolor",
   Callback = function(Color)
       interactHighlightColor = Color
       for _, highlight in pairs(interactableParts) do
           highlight.FillColor = Color
           highlight.OutlineColor = Color
       end
   end
})

local FPSUnlockerToggle = SettingsTab:CreateToggle({
   Name = "FPS Unlocker",
   CurrentValue = false,
   Flag = "fpsunlocker",
   Callback = function(Value)
       if Value then
           setfpscap(999)
       else
           setfpscap(60)
       end
   end,
})

local AutoRejoinToggle = SettingsTab:CreateToggle({
   Name = "Auto-Rejoin on Kick",
   CurrentValue = false,
   Flag = "autorejoin",
   Callback = function(Value)
       if Value then
           game:GetService("CoreGui").RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
               if child.Name == "ErrorPrompt" then
                   TeleportService:Teleport(game.PlaceId)
               end
           end)
       end
   end,
})

-- Config Label
local ConfigLabelSettings = SettingsTab:CreateLabel("Configurations are automatically saved and loaded from PrismHub/Config.json")

-- Misc Tab
local MiscTab = Window:CreateTab("📦 Misc", nil)
local MiscSection = MiscTab:CreateSection("Options")

local chatSpamEnabled = false
local chatSpamMessage = "Prism Universal owns you!"
local chatSpamDelay = 1

local function toggleChatSpam(value)
    chatSpamEnabled = value
    if value then
        spawn(function()
            while chatSpamEnabled do
                ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(chatSpamMessage, "All")
                wait(chatSpamDelay)
            end
        end)
    end
end

local ChatSpamToggle = MiscTab:CreateToggle({
   Name = "Chat Spam",
   CurrentValue = false,
   Flag = "chatspam",
   Callback = function(Value)
       toggleChatSpam(Value)
   end,
})

local ChatSpamInput = MiscTab:CreateInput({
   Name = "Spam Message",
   PlaceholderText = "Enter message",
   RemoveTextAfterFocusLost = false,
   Callback = function(Text)
       chatSpamMessage = Text
   end,
})

local ChatSpamDelaySlider = MiscTab:CreateSlider({
   Name = "Spam Delay",
   Range = {0.1, 5},
   Increment = 0.1,
   Suffix = "Seconds",
   CurrentValue = 1,
   Flag = "spamdelay",
   Callback = function(Value)
       chatSpamDelay = Value
   end,
})

local PlayerInfoDropdown = MiscTab:CreateDropdown({
   Name = "Player Info",
   Options = getPlayerNames(),
   CurrentOption = {""},
   MultipleOptions = false,
   Flag = "playerinfo",
   Callback = function(Option)
       local player = Players:FindFirstChild(Option[1])
       if player then
           local info = "Name: " .. player.Name .. "\nUserId: " .. player.UserId .. "\nTeam: " .. (player.Team and player.Team.Name or "None") .. "\nHealth: " .. (player.Character and player.Character.Humanoid.Health or "N/A")
           PRISM:Notify({
               Title = "Player Info",
               Content = info,
               Duration = 10,
               Image = 13047715178
           })
       end
   end
})

local UnlockAllButton = MiscTab:CreateButton({
   Name = "Unlock All (Attempt)",
   Callback = function()
       for _, v in pairs(workspace:GetDescendants()) do
           if v:IsA("BoolValue") and v.Name:lower():match("locked") then
               v.Value = false
           end
       end
       PRISM:Notify({
           Title = "Unlock All",
           Content = "Attempted to unlock all locked items/doors.",
           Duration = 3,
           Image = 13047715178
       })
   end,
})
