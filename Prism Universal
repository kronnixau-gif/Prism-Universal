local PRISM = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = game.Workspace.CurrentCamera
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")
local TeleportService = game:GetService("TeleportService")
local Debris = game:GetService("Debris")
local VirtualUser = game:GetService("VirtualUser")

_G.notificationsEnabled = true

local function myNotify(options)
    if _G.notificationsEnabled then
        PRISM:Notify(options)
    end
end

local Window = PRISM:CreateWindow({
   Name = "🔥 Prism | Universal 🔫",
   LoadingTitle = "🔫 Universal Script 💥",
   LoadingSubtitle = "By kronnixau",
   ConfigurationSaving = {
      Enabled = true,
      FolderName = "PrismHub",
      FileName = "Config"
   },
   Discord = {
      Enabled = true,
      Invite = "gcjaDpMYce",
      RememberJoins = true
   },
   KeySystem = false,
   KeySettings = {
      Title = "Key | Prism Universal",
      Subtitle = "UI Keybind",
      Note = "Key In Discord Server",
      FileName = "Prism",
      SaveKey = true,
      GrabKeyFromSite = true,
      Key = {"https://pastebin.com/XFfbRsjP"}
   }
})

-- Home Tab
local HomeTab = Window:CreateTab("🏠 Home", nil)
local MainSection = HomeTab:CreateSection("Main")

myNotify({
   Title = "Welcome to Prism Universal",
   Content = "GUI loaded! Use tabs to access features.",
   Duration = 5,
   Image = 13047715178,
   Actions = {
      Ignore = {
         Name = "Okay!",
         Callback = function()
            print("The user tapped Okay!")
         end
      }
   }
})

local WelcomeLabel = HomeTab:CreateLabel("Welcome to Prism Universal! Use the tabs to access all features.")

-- Fly Functionality
_G.flyEnabled = false
local flySpeed = 200
local bodyVelocity, bodyGyro = nil, nil
local flyConnections = {}

local function startFly()
    local player = Players.LocalPlayer
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end

    local humanoidRootPart = character.HumanoidRootPart
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.PlatformStand = true
        humanoid.WalkSpeed = 0
    end

    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = TweenService:Create(humanoidRootPart, tweenInfo, {CFrame = humanoidRootPart.CFrame + Vector3.new(0, 5, 0)})
    tween:Play()

    bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bodyGyro.P = 9e4
    bodyGyro.CFrame = Camera.CFrame
    bodyGyro.Parent = humanoidRootPart

    bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = humanoidRootPart

    local keys = {Forward = 0, Backward = 0, Left = 0, Right = 0, Up = 0, Down = 0}
    
    flyConnections.inputBegan = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.W then keys.Forward = 1 end
        if input.KeyCode == Enum.KeyCode.S then keys.Backward = -1 end
        if input.KeyCode == Enum.KeyCode.A then keys.Left = -1 end
        if input.KeyCode == Enum.KeyCode.D then keys.Right = 1 end
        if input.KeyCode == Enum.KeyCode.Space then keys.Up = 1 end
        if input.KeyCode == Enum.KeyCode.LeftShift then keys.Down = -1 end
    end)

    flyConnections.inputEnded = UserInputService.InputEnded:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.W then keys.Forward = 0 end
        if input.KeyCode == Enum.KeyCode.S then keys.Backward = 0 end
        if input.KeyCode == Enum.KeyCode.A then keys.Left = 0 end
        if input.KeyCode == Enum.KeyCode.D then keys.Right = 0 end
        if input.KeyCode == Enum.KeyCode.Space then keys.Up = 0 end
        if input.KeyCode == Enum.KeyCode.LeftShift then keys.Down = 0 end
    end)

    flyConnections.render = RunService.RenderStepped:Connect(function()
        if _G.flyEnabled and bodyGyro and bodyVelocity then
            bodyGyro.CFrame = Camera.CFrame
            local moveDirection = Vector3.new(keys.Left + keys.Right, keys.Up + keys.Down, -(keys.Forward + keys.Backward))
            if moveDirection.Magnitude > 0 then
                bodyVelocity.Velocity = Camera.CFrame:VectorToWorldSpace(moveDirection.Unit) * flySpeed
            else
                bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            end
        end
    end)
end

local function stopFly()
    local player = Players.LocalPlayer
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.PlatformStand = false
            humanoid.WalkSpeed = 16
        end
    end
    if bodyVelocity then
        bodyVelocity:Destroy()
        bodyVelocity = nil
    end
    if bodyGyro then
        bodyGyro:Destroy()
        bodyGyro = nil
    end
    for _, conn in pairs(flyConnections) do
        conn:Disconnect()
    end
    flyConnections = {}
end

local function toggleFly()
    _G.flyEnabled = not _G.flyEnabled
    if _G.flyEnabled then
        startFly()
        myNotify({
            Title = "Fly",
            Content = "Flying enabled! Use WASD, Space (up), Shift (down).",
            Duration = 3,
            Image = 13047715178
        })
    else
        stopFly()
        myNotify({
            Title = "Fly",
            Content = "Flying disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

-- Noclip Functionality
_G.noclipEnabled = false
local noclipConnection
local collisionParts = {}

local function collectCollisionParts(character)
    collisionParts = {}
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            table.insert(collisionParts, part)
        end
    end
end

local function setCollision(state)
    for _, part in pairs(collisionParts) do
        part.CanCollide = state
    end
end

local function startNoclip()
    local character = Players.LocalPlayer.Character
    if not character then return end
    _G.noclipEnabled = true
    collectCollisionParts(character)
    setCollision(false)
    noclipConnection = RunService.Stepped:Connect(function()
        if _G.noclipEnabled then
            setCollision(false)
        end
    end)
    myNotify({
        Title = "Noclip",
        Content = "Noclip enabled! You can pass through objects.",
        Duration = 3,
        Image = 13047715178
    })
end

local function stopNoclip()
    _G.noclipEnabled = false
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
    end
    setCollision(true)
    collisionParts = {}
    myNotify({
        Title = "Noclip",
        Content = "Noclip disabled!",
        Duration = 3,
        Image = 13047715178
    })
end

-- Keybinds
local keybinds = {
    fly = Enum.KeyCode.F,
    noclip = Enum.KeyCode.G,
    interact = Enum.KeyCode.E
}

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == keybinds.fly then
        toggleFly()
    elseif input.KeyCode == keybinds.noclip then
        if _G.noclipEnabled then
            stopNoclip()
        else
            startNoclip()
        end
    elseif input.KeyCode == keybinds.interact then
        triggerInteraction()
    end
end)

-- Instance Interaction
local interactDistance = 10
local interactHighlightColor = Color3.fromRGB(255, 255, 0)
local interactableParts = {}
local interactConnection

local function isInteractable(part)
    return part:IsA("BasePart") and (part:FindFirstChild("ClickDetector") or part:FindFirstChild("ProximityPrompt") or part.Name:lower():match("door") or part.Name:lower():match("button"))
end

local function highlightInteractable(part)
    if not interactableParts[part] then
        local highlight = Instance.new("Highlight")
        highlight.Name = "InteractHighlight"
        highlight.Adornee = part
        highlight.FillColor = interactHighlightColor
        highlight.OutlineColor = interactHighlightColor
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.Parent = part
        interactableParts[part] = highlight
    end
end

local function removeHighlight(part)
    if interactableParts[part] then
        interactableParts[part]:Destroy()
        interactableParts[part] = nil
    end
end

local function triggerInteraction()
    local player = Players.LocalPlayer
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local root = character.HumanoidRootPart
    local closestPart = nil
    local closestDist = interactDistance
    for part, _ in pairs(interactableParts) do
        local dist = (part.Position - root.Position).Magnitude
        if dist <= closestDist then
            closestDist = dist
            closestPart = part
        end
    end
    if closestPart then
        if closestPart:FindFirstChild("ClickDetector") then
            fireclickdetector(closestPart.ClickDetector)
        elseif closestPart:FindFirstChild("ProximityPrompt") then
            fireproximityprompt(closestPart.ProximityPrompt)
        elseif closestPart:IsA("BasePart") then
            pcall(function() closestPart:Activate() end)
        end
        myNotify({
            Title = "Interaction",
            Content = "Interacted with " .. closestPart.Name,
            Duration = 3,
            Image = 13047715178
        })
    end
end

local function updateInteractables()
    local player = Players.LocalPlayer
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local root = character.HumanoidRootPart
    local region = Region3.new(root.Position - Vector3.new(interactDistance, interactDistance, interactDistance), root.Position + Vector3.new(interactDistance, interactDistance, interactDistance))
    local parts = workspace:FindPartsInRegion3(region, character, 100)
    for _, part in pairs(parts) do
        if isInteractable(part) then
            highlightInteractable(part)
        else
            removeHighlight(part)
        end
    end
    for part, _ in pairs(interactableParts) do
        if (part.Position - root.Position).Magnitude > interactDistance then
            removeHighlight(part)
        end
    end
end

-- Kill All
local function killAll()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = player.Character.Humanoid
            pcall(function() humanoid.Health = 0 end)
            if player.Character:FindFirstChild("HumanoidRootPart") then
                local bv = Instance.new("BodyVelocity")
                bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
                bv.Velocity = Vector3.new(0, -1000, 0)
                bv.Parent = player.Character.HumanoidRootPart
                Debris:AddItem(bv, 0.1)
            end
            for _, remote in pairs(ReplicatedStorage:GetDescendants()) do
                if remote:IsA("RemoteEvent") and (remote.Name:lower():match("damage") or remote.Name:lower():match("hit")) then
                    pcall(function()
                        remote:FireServer(player.Character.Humanoid, math.huge)
                    end)
                end
            end
        end
    end
    myNotify({
        Title = "Kill All",
        Content = "Attempted to kill all players!",
        Duration = 3,
        Image = 13047715178
    })
end

-- Home Tab Features
local FlyQuickToggle = HomeTab:CreateToggle({
   Name = "Quick Toggle Fly",
   CurrentValue = false,
   Flag = "quickfly",
   Callback = function(Value)
       toggleFly()
   end,
})

local NoclipQuickToggle = HomeTab:CreateToggle({
   Name = "Quick Toggle Noclip",
   CurrentValue = false,
   Flag = "quicknoclip",
   Callback = function(Value)
       if Value then
           startNoclip()
       else
           stopNoclip()
       end
   end,
})

local KillAllQuickButton = HomeTab:CreateButton({
   Name = "Quick Kill All",
   Callback = function()
       killAll()
   end,
})

local ConfigLabel = HomeTab:CreateLabel("Configurations are automatically saved and loaded from PrismHub/Config.json")

-- Movement Tab
local MovementTab = Window:CreateTab("🏃 Movement", nil)
local MovementSection = MovementTab:CreateSection("Options")

local FlyButton = MovementTab:CreateButton({
   Name = "Toggle Fly",
   Callback = function()
       toggleFly()
   end,
})

local FlySpeedSlider = MovementTab:CreateSlider({
   Name = "Fly Speed",
   Range = {10, 1000},
   Increment = 10,
   Suffix = "Speed",
   CurrentValue = 200,
   Flag = "flyspeed",
   Callback = function(Value)
       flySpeed = Value
   end,
})

local NoclipButton = MovementTab:CreateButton({
   Name = "Toggle Noclip",
   Callback = function()
       if _G.noclipEnabled then
           stopNoclip()
       else
           startNoclip()
       end
   end,
})

local SpeedHackSlider = MovementTab:CreateSlider({
   Name = "Speed Hack",
   Range = {16, 500},
   Increment = 1,
   Suffix = "Speed",
   CurrentValue = 16,
   Flag = "speedhack",
   Callback = function(Value)
       local character = Players.LocalPlayer.Character
       if character then
           local humanoid = character:FindFirstChildOfClass("Humanoid")
           if humanoid then
               humanoid.WalkSpeed = Value
           end
       end
   end,
})

local JumpHackSlider = MovementTab:CreateSlider({
   Name = "Jump Hack",
   Range = {50, 500},
   Increment = 1,
   Suffix = "Power",
   CurrentValue = 50,
   Flag = "jumphack",
   Callback = function(Value)
       local character = Players.LocalPlayer.Character
       if character then
           local humanoid = character:FindFirstChildOfClass("Humanoid")
           if humanoid then
               humanoid.JumpPower = Value
           end
       end
   end,
})

local AntiAimToggle = MovementTab:CreateToggle({
   Name = "Anti-Aim",
   CurrentValue = false,
   Flag = "antiaim",
   Callback = function(Value)
       _G.antiAimEnabled = Value
       if Value then
           RunService:BindToRenderStep("AntiAim", Enum.RenderPriority.Camera.Value + 1, function()
               local character = Players.LocalPlayer.Character
               if character and character:FindFirstChild("HumanoidRootPart") then
                   character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(math.random(-180, 180)), 0)
               end
           end)
       else
           RunService:UnbindFromRenderStep("AntiAim")
       end
   end,
})

local BunnyHopToggle = MovementTab:CreateToggle({
   Name = "Bunny Hop",
   CurrentValue = false,
   Flag = "bunnyhop",
   Callback = function(Value)
       _G.bunnyHopEnabled = Value
       if Value then
           RunService:BindToRenderStep("BunnyHop", Enum.RenderPriority.Input.Value, function()
               local character = Players.LocalPlayer.Character
               if character and character:FindFirstChildOfClass("Humanoid") then
                   local humanoid = character.Humanoid
                   if humanoid:GetState() == Enum.HumanoidStateType.Freefall and UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                       humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                   end
               end
           end)
       else
           RunService:UnbindFromRenderStep("BunnyHop")
       end
   end,
})

local InfiniteJumpToggle = MovementTab:CreateToggle({
   Name = "Infinite Jump",
   CurrentValue = false,
   Flag = "infinitejump",
   Callback = function(Value)
       _G.infiniteJumpEnabled = Value
       if Value then
           UserInputService.JumpRequest:Connect(function()
               if _G.infiniteJumpEnabled then
                   local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                   if humanoid then
                       humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                   end
               end
           end)
       end
   end,
})

local AirWalkToggle = MovementTab:CreateToggle({
   Name = "Air Walk",
   CurrentValue = false,
   Flag = "airwalk",
   Callback = function(Value)
       _G.airWalkEnabled = Value
       local platform = Instance.new("Part")
       platform.Size = Vector3.new(5, 1, 5)
       platform.Transparency = 1
       platform.Anchored = true
       platform.Parent = workspace
       if Value then
           RunService:BindToRenderStep("AirWalk", Enum.RenderPriority.Character.Value, function()
               local character = Players.LocalPlayer.Character
               if character and character:FindFirstChild("HumanoidRootPart") then
                   platform.CFrame = character.HumanoidRootPart.CFrame - Vector3.new(0, 3, 0)
               end
           end)
       else
           RunService:UnbindFromRenderStep("AirWalk")
           platform:Destroy()
       end
   end,
})

local SpiderClimbToggle = MovementTab:CreateToggle({
   Name = "Spider Climb",
   CurrentValue = false,
   Flag = "spiderclimb",
   Callback = function(Value)
       _G.spiderClimbEnabled = Value
       if Value then
           RunService:BindToRenderStep("SpiderClimb", Enum.RenderPriority.Input.Value, function()
               local character = Players.LocalPlayer.Character
               if character and character:FindFirstChild("HumanoidRootPart") and UserInputService:IsKeyDown(Enum.KeyCode.W) then
                   local ray = Ray.new(character.HumanoidRootPart.Position, character.HumanoidRootPart.CFrame.LookVector * 2)
                   local hit, pos, normal = workspace:FindPartOnRay(ray, character)
                   if hit then
                       character.HumanoidRootPart.Velocity = normal * 50
                   end
               end
           end)
       else
           RunService:UnbindFromRenderStep("SpiderClimb")
       end
   end,
})

local function getPlayerNames()
    local names = {"Nobody"}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            table.insert(names, player.Name)
        end
    end
    return names
end

local TeleportDropdown = MovementTab:CreateDropdown({
   Name = "Teleport to Player",
   Options = getPlayerNames(),
   CurrentOption = {"Nobody"},
   MultipleOptions = false,
   Flag = "teleportplayer",
   Callback = function(Option)
       if Option[1] == "Nobody" then return end
       local targetPlayer = Players:FindFirstChild(Option[1])
       if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
           local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Linear)
           local tween = TweenService:Create(Players.LocalPlayer.Character.HumanoidRootPart, tweenInfo, {CFrame = targetPlayer.Character.HumanoidRootPart.CFrame})
           tween:Play()
           myNotify({
               Title = "Teleport",
               Content = "Teleported to " .. targetPlayer.Name,
               Duration = 3,
               Image = 13047715178
           })
       end
       TeleportDropdown:Set({"Nobody"})
   end
})

Players.PlayerAdded:Connect(function()
    TeleportDropdown:Set(getPlayerNames())
end)
Players.PlayerRemoving:Connect(function()
    TeleportDropdown:Set(getPlayerNames())
end)

-- Visuals Tab
local VisualsTab = Window:CreateTab("🎨 Visuals", nil)
local VisualsSection = VisualsTab:CreateSection("Options")

local espFeatures = {
    box = false,
    name = false,
    distance = false,
    health = false,
    tracers = false,
    teamFilter = false,
    textOutline = true,
    useTeamColors = false,
    skeleton = false,
    item = false,
    chams = false
}
local espColors = {
    box = Color3.fromRGB(255, 255, 255),
    text = Color3.fromRGB(255, 255, 255),
    tracer = Color3.fromRGB(255, 255, 255),
    skeleton = Color3.fromRGB(255, 255, 255),
    item = Color3.fromRGB(0, 255, 0),
    chams = Color3.fromRGB(255, 0, 0)
}
local playerESP = {}
local itemESP = {}

local function shouldShowESP(player)
    if player == Players.LocalPlayer then return false end
    if espFeatures.teamFilter and player.Team == Players.LocalPlayer.Team then return false end
    return true
end

local function getESPColor(player)
    return espFeatures.useTeamColors and player.Team and player.TeamColor.Color or nil
end

local function createBox(player)
    if not shouldShowESP(player) or not player.Character then return end
    local box = Drawing.new("Quad")
    box.Visible = false
    box.Color = getESPColor(player) or espColors.box
    box.Thickness = 1
    box.Transparency = 1
    box.Filled = false
    if not playerESP[player] then playerESP[player] = {} end
    playerESP[player].box = box
end

local function updateBox(player)
    if playerESP[player] and playerESP[player].box and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Head") then
        local box = playerESP[player].box
        local rootPos, onScreen = Camera:WorldToViewportPoint(player.Character.HumanoidRootPart.Position)
        if not onScreen then
            box.Visible = false
            return
        end
        local headPos = Camera:WorldToViewportPoint(player.Character.Head.Position + Vector3.new(0, 0.5, 0))
        local legPos = Camera:WorldToViewportPoint(player.Character.HumanoidRootPart.Position - Vector3.new(0, 4, 0))
        local leftPos = Camera:WorldToViewportPoint(player.Character.HumanoidRootPart.Position - Camera.CFrame.RightVector * 2)
        local rightPos = Camera:WorldToViewportPoint(player.Character.HumanoidRootPart.Position + Camera.CFrame.RightVector * 2)
        local top = Vector2.new((leftPos.X + rightPos.X) / 2, headPos.Y)
        local bottom = Vector2.new((leftPos.X + rightPos.X) / 2, legPos.Y)
        local width = math.abs(leftPos.X - rightPos.X) * 1.2
        local topLeft = Vector2.new(top.X - width / 2, top.Y)
        local topRight = Vector2.new(top.X + width / 2, top.Y)
        local bottomLeft = Vector2.new(bottom.X - width / 2, bottom.Y)
        local bottomRight = Vector2.new(bottom.X + width / 2, bottom.Y)
        box.PointA = topLeft
        box.PointB = topRight
        box.PointC = bottomRight
        box.PointD = bottomLeft
        box.Color = getESPColor(player) or espColors.box
        box.Visible = true
    else
        if playerESP[player] and playerESP[player].box then
            playerESP[player].box.Visible = false
        end
    end
end

local function createTextESP(player)
    if not shouldShowESP(player) or not player.Character or not player.Character:FindFirstChild("Head") then return end
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESPText"
    billboard.Adornee = player.Character.Head
    billboard.Size = UDim2.new(0, 150, 0, 60)
    billboard.StudsOffset = Vector3.new(0, 4, 0)
    billboard.AlwaysOnTop = true
    local text = Instance.new("TextLabel")
    text.Size = UDim2.new(1, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.TextColor3 = getESPColor(player) or espColors.text
    text.TextSize = 14
    text.Font = Enum.Font.SourceSansBold
    text.TextStrokeTransparency = espFeatures.textOutline and 0 or 1
    text.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    text.TextYAlignment = Enum.TextYAlignment.Top
    text.Parent = billboard
    billboard.Parent = player.Character.Head
    if not playerESP[player] then playerESP[player] = {} end
    playerESP[player].text = {gui = billboard, label = text}
end

local function updateTextESP(player)
    if playerESP[player] and playerESP[player].text and player.Character then
        local lines = {}
        if espFeatures.name then
            table.insert(lines, player.Name)
        end
        if espFeatures.distance then
            local dist = math.floor((Players.LocalPlayer.Character and Players.LocalPlayer.Character.HumanoidRootPart and player.Character.HumanoidRootPart and (Players.LocalPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude) or 0)
            table.insert(lines, dist .. " studs")
        end
        if espFeatures.health then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                table.insert(lines, math.floor(humanoid.Health) .. "/" .. humanoid.MaxHealth)
            end
        end
        playerESP[player].text.label.Text = table.concat(lines, "\n")
        playerESP[player].text.label.TextStrokeTransparency = espFeatures.textOutline and 0 or 1
        playerESP[player].text.label.TextColor3 = getESPColor(player) or espColors.text
    end
end

local function createTracer(player)
    if not shouldShowESP(player) or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    local tracer = Drawing.new("Line")
    tracer.Visible = false
    tracer.Color = getESPColor(player) or espColors.tracer
    tracer.Thickness = 1
    tracer.Transparency = 1
    if not playerESP[player] then playerESP[player] = {} end
    playerESP[player].tracer = tracer
end

local function updateTracer(player)
    if playerESP[player] and playerESP[player].tracer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local tracer = playerESP[player].tracer
        local targetPos = player.Character.HumanoidRootPart.Position
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
        local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
        tracer.From = center
        tracer.To = Vector2.new(screenPos.X, screenPos.Y)
        tracer.Color = getESPColor(player) or espColors.tracer
        tracer.Visible = onScreen
    else
        if playerESP[player] and playerESP[player].tracer then
            playerESP[player].tracer.Visible = false
        end
    end
end

local function createSkeleton(player)
    if not shouldShowESP(player) or not player.Character then return end
    local skeletonLines = {}
    local parts = {"Head", "UpperTorso", "LowerTorso", "LeftUpperArm", "RightUpperArm", "LeftLowerArm", "RightLowerArm", "LeftHand", "RightHand", "LeftUpperLeg", "RightUpperLeg", "LeftLowerLeg", "RightLowerLeg", "LeftFoot", "RightFoot"}
    for _, partName in pairs(parts) do
        if player.Character:FindFirstChild(partName) then
            local line = Drawing.new("Line")
            line.Visible = false
            line.Color = getESPColor(player) or espColors.skeleton
            line.Thickness = 1
            line.Transparency = 1
            skeletonLines[partName] = line
        end
    end
    if not playerESP[player] then playerESP[player] = {} end
    playerESP[player].skeleton = skeletonLines
end

local function updateSkeleton(player)
    if playerESP[player] and playerESP[player].skeleton and player.Character then
        local connections = {
            ["Head"] = "UpperTorso",
            ["UpperTorso"] = "LowerTorso",
            ["UpperTorso"] = "LeftUpperArm",
            ["UpperTorso"] = "RightUpperArm",
            ["LeftUpperArm"] = "LeftLowerArm",
            ["RightUpperArm"] = "RightLowerArm",
            ["LeftLowerArm"] = "LeftHand",
            ["RightLowerArm"] = "RightHand",
            ["LowerTorso"] = "LeftUpperLeg",
            ["LowerTorso"] = "RightUpperLeg",
            ["LeftUpperLeg"] = "LeftLowerLeg",
            ["RightUpperLeg"] = "RightLowerLeg",
            ["LeftLowerLeg"] = "LeftFoot",
            ["RightLowerLeg"] = "RightFoot"
        }
        for fromPart, toPart in pairs(connections) do
            if player.Character:FindFirstChild(fromPart) and player.Character:FindFirstChild(toPart) then
                local fromPos, fromOn = Camera:WorldToViewportPoint(player.Character[fromPart].Position)
                local toPos, toOn = Camera:WorldToViewportPoint(player.Character[toPart].Position)
                local line = playerESP[player].skeleton[fromPart] or playerESP[player].skeleton[toPart]
                if line then
                    line.From = Vector2.new(fromPos.X, fromPos.Y)
                    line.To = Vector2.new(toPos.X, toPos.Y)
                    line.Color = getESPColor(player) or espColors.skeleton
                    line.Visible = fromOn and toOn
                end
            end
        end
    else
        if playerESP[player] and playerESP[player].skeleton then
            for _, line in pairs(playerESP[player].skeleton) do
                line.Visible = false
            end
        end
    end
end

local function createItemESP(item)
    if not item:IsA("BasePart") or itemESP[item] then return end
    local highlight = Instance.new("Highlight")
    highlight.Name = "ItemESP"
    highlight.Adornee = item
    highlight.FillColor = espColors.item
    highlight.OutlineColor = espColors.item
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.Parent = item
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ItemText"
    billboard.Adornee = item
    billboard.Size = UDim2.new(0, 100, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 2, 0)
    billboard.AlwaysOnTop = true
    local text = Instance.new("TextLabel")
    text.Size = UDim2.new(1, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.TextColor3 = espColors.text
    text.TextSize = 12
    text.Text = item.Name
    text.Parent = billboard
    billboard.Parent = item
    itemESP[item] = {highlight = highlight, billboard = billboard}
end

local function removeItemESP(item)
    if itemESP[item] then
        itemESP[item].highlight:Destroy()
        itemESP[item].billboard:Destroy()
        itemESP[item] = nil
    end
end

local function addChams(player)
    if not shouldShowESP(player) or not player.Character then return end
    local highlight = Instance.new("Highlight")
    highlight.Name = "ChamsHighlight"
    highlight.Adornee = player.Character
    highlight.FillColor = getESPColor(player) or espColors.chams
    highlight.OutlineColor = Color3.fromRGB(0, 0, 0)
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.Parent = player.Character
    if not playerESP[player] then playerESP[player] = {} end
    playerESP[player].chams = highlight
end

local function removeChams(player)
    if playerESP[player] and playerESP[player].chams then
        playerESP[player].chams:Destroy()
        playerESP[player].chams = nil
    end
end

local function toggleESPFeature(feature, value)
    espFeatures[feature] = value
    if value then
        if feature == "item" then
            for _, item in pairs(workspace:GetDescendants()) do
                if item:IsA("BasePart") and (item.Name:lower():match("item") or item.Name:lower():match("tool")) then
                    createItemESP(item)
                end
            end
            local itemAddedConn = workspace.DescendantAdded:Connect(function(item)
                if espFeatures.item and item:IsA("BasePart") and (item.Name:lower():match("item") or item.Name:lower():match("tool")) then
                    createItemESP(item)
                end
            end)
            local itemRemovingConn = workspace.DescendantRemoving:Connect(function(item)
                removeItemESP(item)
            end)
            if not playerESP.connections then playerESP.connections = {} end
            table.insert(playerESP.connections, itemAddedConn)
            table.insert(playerESP.connections, itemRemovingConn)
        elseif feature == "chams" then
            for _, player in pairs(Players:GetPlayers()) do
                if shouldShowESP(player) and player.Character then
                    addChams(player)
                end
            end
            local addedConn = Players.PlayerAdded:Connect(function(player)
                if shouldShowESP(player) then
                    player.CharacterAdded:Connect(function()
                        if espFeatures.chams then
                            addChams(player)
                        end
                    end)
                end
            end)
            if not playerESP.connections then playerESP.connections = {} end
            table.insert(playerESP.connections, addedConn)
        else
            for _, player in pairs(Players:GetPlayers()) do
                if shouldShowESP(player) and player.Character then
                    if feature == "box" then createBox(player) end
                    if feature == "tracers" then createTracer(player) end
                    if feature == "skeleton" then createSkeleton(player) end
                    if feature == "name" or feature == "distance" or feature == "health" then
                        createTextESP(player)
                        updateTextESP(player)
                    end
                end
            end
        end
        myNotify({
            Title = "ESP",
            Content = feature:gsub("^%l", string.upper) .. " enabled!",
            Duration = 3,
            Image = 13047715178
        })
    else
        if feature == "item" then
            for item, _ in pairs(itemESP) do
                removeItemESP(item)
            end
        elseif feature == "chams" then
            for _, player in pairs(Players:GetPlayers()) do
                removeChams(player)
            end
        else
            for _, player in pairs(Players:GetPlayers()) do
                if playerESP[player] then
                    if feature == "box" and playerESP[player].box then
                        playerESP[player].box:Remove()
                        playerESP[player].box = nil
                    elseif feature == "tracers" and playerESP[player].tracer then
                        playerESP[player].tracer:Remove()
                        playerESP[player].tracer = nil
                    elseif feature == "skeleton" and playerESP[player].skeleton then
                        for _, line in pairs(playerESP[player].skeleton) do
                            line:Remove()
                        end
                        playerESP[player].skeleton = nil
                    elseif feature == "name" or feature == "distance" or feature == "health" then
                        if playerESP[player].text and not (espFeatures.name or espFeatures.distance or espFeatures.health) then
                            playerESP[player].text.gui:Destroy()
                            playerESP[player].text = nil
                        else
                            updateTextESP(player)
                        end
                    end
                end
            end
        end
        myNotify({
            Title = "ESP",
            Content = feature:gsub("^%l", string.upper) .. " disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

local function updateTextOutline()
    for _, player in pairs(Players:GetPlayers()) do
        if playerESP[player] and playerESP[player].text then
            playerESP[player].text.label.TextStrokeTransparency = espFeatures.textOutline and 0 or 1
        end
    end
end

RunService.RenderStepped:Connect(function()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if espFeatures.box then updateBox(player) end
            if espFeatures.tracers then updateTracer(player) end
            if espFeatures.skeleton then updateSkeleton(player) end
            if espFeatures.name or espFeatures.distance or espFeatures.health then updateTextESP(player) end
        end
    end
    updateInteractables()
end)

Players.PlayerAdded:Connect(function(player)
    if shouldShowESP(player) then
        player.CharacterAdded:Connect(function(character)
            if character and character:FindFirstChild("HumanoidRootPart") then
                if espFeatures.box then createBox(player) end
                if espFeatures.tracers then createTracer(player) end
                if espFeatures.skeleton then createSkeleton(player) end
                if espFeatures.chams then addChams(player) end
                if espFeatures.name or espFeatures.distance or espFeatures.health then
                    createTextESP(player)
                    updateTextESP(player)
                end
            end
        end)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if playerESP[player] then
        for _, feature in pairs({"box", "tracer", "skeleton", "text", "chams"}) do
            if playerESP[player][feature] then
                if feature == "box" or feature == "tracer" then
                    playerESP[player][feature]:Remove()
                elseif feature == "skeleton" then
                    for _, line in pairs(playerESP[player].skeleton) do
                        line:Remove()
                    end
                elseif feature == "text" then
                    playerESP[player].text.gui:Destroy()
                elseif feature == "chams" then
                    playerESP[player].chams:Destroy()
                end
                playerESP[player][feature] = nil
            end
        end
        playerESP[player] = nil
    end
end)

-- ESP Toggles and Color Pickers
local BoxToggle = VisualsTab:CreateToggle({
   Name = "Box ESP",
   CurrentValue = false,
   Flag = "boxesp",
   Callback = function(Value)
       toggleESPFeature("box", Value)
   end,
})

local BoxColorPicker = VisualsTab:CreateColorPicker({
   Name = "Box Color",
   Color = Color3.fromRGB(255, 255, 255),
   Flag = "boxcolor",
   Callback = function(Color)
       espColors.box = Color
       for player, esp in pairs(playerESP) do
           if esp.box then
               esp.box.Color = getESPColor(player) or Color
           end
       end
   end
})

local NameToggle = VisualsTab:CreateToggle({
   Name = "Name ESP",
   CurrentValue = false,
   Flag = "nameesp",
   Callback = function(Value)
       toggleESPFeature("name", Value)
   end,
})

local DistanceToggle = VisualsTab:CreateToggle({
   Name = "Distance ESP",
   CurrentValue = false,
   Flag = "distanceesp",
   Callback = function(Value)
       toggleESPFeature("distance", Value)
   end,
})

local HealthToggle = VisualsTab:CreateToggle({
   Name = "Health ESP",
   CurrentValue = false,
   Flag = "healthesp",
   Callback = function(Value)
       toggleESPFeature("health", Value)
   end,
})

local TextColorPicker = VisualsTab:CreateColorPicker({
   Name = "Text Color",
   Color = Color3.fromRGB(255, 255, 255),
   Flag = "textcolor",
   Callback = function(Color)
       espColors.text = Color
       for player, esp in pairs(playerESP) do
           if esp.text then
               esp.text.label.TextColor3 = getESPColor(player) or Color
           end
       end
   end
})

local TextOutlineToggle = VisualsTab:CreateToggle({
   Name = "Text Outline",
   CurrentValue = true,
   Flag = "textoutline",
   Callback = function(Value)
       espFeatures.textOutline = Value
       updateTextOutline()
   end,
})

local TracersToggle = VisualsTab:CreateToggle({
   Name = "Tracers ESP",
   CurrentValue = false,
   Flag = "tracersesp",
   Callback = function(Value)
       toggleESPFeature("tracers", Value)
   end,
})

local TracerColorPicker = VisualsTab:CreateColorPicker({
   Name = "Tracer Color",
   Color = Color3.fromRGB(255, 255, 255),
   Flag = "tracercolor",
   Callback = function(Color)
       espColors.tracer = Color
       for player, esp in pairs(playerESP) do
           if esp.tracer then
               esp.tracer.Color = getESPColor(player) or Color
           end
       end
   end
})

local SkeletonToggle = VisualsTab:CreateToggle({
   Name = "Skeleton ESP",
   CurrentValue = false,
   Flag = "skeletonesp",
   Callback = function(Value)
       toggleESPFeature("skeleton", Value)
   end,
})

local SkeletonColorPicker = VisualsTab:CreateColorPicker({
   Name = "Skeleton Color",
   Color = Color3.fromRGB(255, 255, 255),
   Flag = "skeletoncolor",
   Callback = function(Color)
       espColors.skeleton = Color
       for player, esp in pairs(playerESP) do
           if esp.skeleton then
               for _, line in pairs(esp.skeleton) do
                   line.Color = getESPColor(player) or Color
               end
           end
       end
   end
})

local ItemESPToggle = VisualsTab:CreateToggle({
   Name = "Item ESP",
   CurrentValue = false,
   Flag = "itemesp",
   Callback = function(Value)
       toggleESPFeature("item", Value)
   end,
})

local ItemColorPicker = VisualsTab:CreateColorPicker({
   Name = "Item Color",
   Color = Color3.fromRGB(0, 255, 0),
   Flag = "itemcolor",
   Callback = function(Color)
       espColors.item = Color
       for _, data in pairs(itemESP) do
           data.highlight.FillColor = Color
           data.highlight.OutlineColor = Color
       end
   end
})

local ChamsToggle = VisualsTab:CreateToggle({
   Name = "Chams",
   CurrentValue = false,
   Flag = "chams",
   Callback = function(Value)
       toggleESPFeature("chams", Value)
   end,
})

local ChamsColorPicker = VisualsTab:CreateColorPicker({
   Name = "Chams Color",
   Color = Color3.fromRGB(255, 0, 0),
   Flag = "chamscolor",
   Callback = function(Color)
       espColors.chams = Color
       for player, esp in pairs(playerESP) do
           if esp.chams then
               esp.chams.FillColor = getESPColor(player) or Color
           end
       end
   end
})

local TeamFilterToggle = VisualsTab:CreateToggle({
   Name = "Team Filter",
   CurrentValue = false,
   Flag = "teamfilter",
   Callback = function(Value)
       espFeatures.teamFilter = Value
       for _, player in pairs(Players:GetPlayers()) do
           if playerESP[player] then
               for feature in pairs(playerESP[player]) do
                   if feature ~= "connections" then
                       if feature == "box" or feature == "tracer" then
                           playerESP[player][feature]:Remove()
                       elseif feature == "skeleton" then
                           for _, line in pairs(playerESP[player].skeleton) do
                               line:Remove()
                           end
                       elseif feature == "text" then
                           playerESP[player].text.gui:Destroy()
                       elseif feature == "chams" then
                           playerESP[player].chams:Destroy()
                       end
                       playerESP[player][feature] = nil
                   end
               end
           end
           if shouldShowESP(player) and player.Character then
               if espFeatures.box then createBox(player) end
               if espFeatures.tracers then createTracer(player) end
               if espFeatures.skeleton then createSkeleton(player) end
               if espFeatures.chams then addChams(player) end
               if espFeatures.name or espFeatures.distance or espFeatures.health then
                   createTextESP(player)
                   updateTextESP(player)
               end
           end
       end
   end,
})

local UseTeamColorsToggle = VisualsTab:CreateToggle({
   Name = "Use Team Colors",
   CurrentValue = false,
   Flag = "useteamcolors",
   Callback = function(Value)
       espFeatures.useTeamColors = Value
       for _, player in pairs(Players:GetPlayers()) do
           if playerESP[player] then
               if playerESP[player].box then
                   playerESP[player].box.Color = getESPColor(player) or espColors.box
               end
               if playerESP[player].text then
                   playerESP[player].text.label.TextColor3 = getESPColor(player) or espColors.text
               end
               if playerESP[player].tracer then
                   playerESP[player].tracer.Color = getESPColor(player) or espColors.tracer
               end
               if playerESP[player].skeleton then
                   for _, line in pairs(playerESP[player].skeleton) do
                       line.Color = getESPColor(player) or espColors.skeleton
                   end
               end
               if playerESP[player].chams then
                   playerESP[player].chams.FillColor = getESPColor(player) or espColors.chams
               end
           end
       end
   end,
})

local FullbrightToggle = VisualsTab:CreateToggle({
   Name = "Fullbright",
   CurrentValue = false,
   Flag = "fullbright",
   Callback = function(Value)
       if Value then
           Lighting.Brightness = 2
           Lighting.GlobalShadows = false
           Lighting.FogEnd = 9e9
       else
           Lighting.Brightness = 1
           Lighting.GlobalShadows = true
           Lighting.FogEnd = 1000
       end
   end,
})

local CrosshairToggle = VisualsTab:CreateToggle({
   Name = "Custom Crosshair",
   CurrentValue = false,
   Flag = "crosshair",
   Callback = function(Value)
       local crosshair = Drawing.new("Circle")
       crosshair.Visible = Value
       crosshair.Color = Color3.fromRGB(255, 0, 0)
       crosshair.Thickness = 1
       crosshair.NumSides = 100
       crosshair.Radius = 5
       crosshair.Filled = true
       crosshair.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
       if Value then
           RunService:BindToRenderStep("Crosshair", Enum.RenderPriority.Camera.Value, function()
               crosshair.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
           end)
       else
           RunService:UnbindFromRenderStep("Crosshair")
           crosshair:Remove()
       end
   end,
})

local FOVChangerSlider = VisualsTab:CreateSlider({
   Name = "FOV Changer",
   Range = {30, 120},
   Increment = 1,
   Suffix = "Degrees",
   CurrentValue = 70,
   Flag = "fovchanger",
   Callback = function(Value)
       Camera.FieldOfView = Value
   end,
})

local XRayToggle = VisualsTab:CreateToggle({
   Name = "X-Ray (Transparent Walls)",
   CurrentValue = false,
   Flag = "xray",
   Callback = function(Value)
       for _, part in pairs(workspace:GetDescendants()) do
           if part:IsA("BasePart") and not part.Parent:FindFirstChildOfClass("Humanoid") then
               part.Transparency = Value and 0.5 or 0
           end
       end
   end,
})

-- Combat Tab
local CombatTab = Window:CreateTab("🔫 Combat", nil)
local CombatSection = CombatTab:CreateSection("Options")

local aimbotEnabled = false
local aimbotTargetPart = "Head"
local aimbotFOV = 200
local aimbotSmoothness = 0.5
local aimbotVisibleCheck = false
local aimbotTeamFilter = false
local aimbotKey = Enum.UserInputType.MouseButton2
local aimbotConnection
local showFOV = false
local fovCircle = Drawing.new("Circle")
fovCircle.Visible = false
fovCircle.Thickness = 1
fovCircle.NumSides = 100
fovCircle.Radius = aimbotFOV
fovCircle.Color = Color3.fromRGB(255, 0, 0)
fovCircle.Filled = false
fovCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
local fovColor = Color3.fromRGB(255, 0, 0)

local function updateFOVCircle()
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    fovCircle.Radius = aimbotFOV
    fovCircle.Color = fovColor
    fovCircle.Visible = showFOV
end

RunService.RenderStepped:Connect(updateFOVCircle)

local function getClosestPlayerInFOV()
    local localPlayer = Players.LocalPlayer
    local localChar = localPlayer.Character
    if not localChar or not localChar:FindFirstChild("Head") then return nil end

    local closestPlayer = nil
    local closestDistance = aimbotFOV
    local center = Camera.ViewportSize / 2

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and (not aimbotTeamFilter or player.Team ~= localPlayer.Team) and player.Character and player.Character:FindFirstChild(aimbotTargetPart) and player.Character:FindFirstChildOfClass("Humanoid") and player.Character.Humanoid.Health > 0 then
            local targetPos = player.Character[aimbotTargetPart].Position
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
            if onScreen then
                local distance = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                if distance < closestDistance then
                    if not aimbotVisibleCheck then
                        closestDistance = distance
                        closestPlayer = player
                    else
                        local ray = Ray.new(Camera.CFrame.Position, (targetPos - Camera.CFrame.Position).Unit * 1000)
                        local hit, _ = workspace:FindPartOnRayWithIgnoreList(ray, {localChar})
                        if hit and hit:IsDescendantOf(player.Character) then
                            closestDistance = distance
                            closestPlayer = player
                        end
                    end
                end
            end
        end
    end

    return closestPlayer
end

local function toggleAimbot(value)
    aimbotEnabled = value
    if aimbotEnabled then
        aimbotConnection = RunService.RenderStepped:Connect(function()
            if UserInputService:IsMouseButtonPressed(aimbotKey) then
                local target = getClosestPlayerInFOV()
                if target and target.Character and target.Character:FindFirstChild(aimbotTargetPart) then
                    local targetPos = target.Character[aimbotTargetPart].Position
                    local newCFrame = CFrame.lookAt(Camera.CFrame.Position, targetPos)
                    Camera.CFrame = Camera.CFrame:Lerp(newCFrame, aimbotSmoothness)
                end
            end
        end)
        myNotify({
            Title = "Aimbot",
            Content = "Aimbot enabled! Hold right mouse to aim.",
            Duration = 3,
            Image = 13047715178
        })
    else
        if aimbotConnection then
            aimbotConnection:Disconnect()
            aimbotConnection = nil
        end
        myNotify({
            Title = "Aimbot",
            Content = "Aimbot disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

local triggerbotEnabled = false
local triggerbotConnection

local function toggleTriggerbot(value)
    triggerbotEnabled = value
    if triggerbotEnabled then
        triggerbotConnection = RunService.RenderStepped:Connect(function()
            local target = getClosestPlayerInFOV()
            if target and target.Character and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
                local tool = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
                if tool then
                    tool:Activate()
                end
            end
        end)
        myNotify({
            Title = "Triggerbot",
            Content = "Triggerbot enabled!",
            Duration = 3,
            Image = 13047715178
        })
    else
        if triggerbotConnection then
            triggerbotConnection:Disconnect()
            triggerbotConnection = nil
        end
        myNotify({
            Title = "Triggerbot",
            Content = "Triggerbot disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

local autoHeadshotEnabled = false
local autoHeadshotConnection

local function toggleAutoHeadshot(value)
    autoHeadshotEnabled = value
    if autoHeadshotEnabled then
        autoHeadshotConnection = RunService.RenderStepped:Connect(function()
            local target = getClosestPlayerInFOV()
            if target and target.Character and target.Character:FindFirstChild("Head") then
                local headPos = target.Character.Head.Position
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, headPos)
            end
        end)
        myNotify({
            Title = "Auto Headshot",
            Content = "Auto Headshot enabled!",
            Duration = 3,
            Image = 13047715178
        })
    else
        if autoHeadshotConnection then
            autoHeadshotConnection:Disconnect()
            autoHeadshotConnection = nil
        end
        myNotify({
            Title = "Auto Headshot",
            Content = "Auto Headshot disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

local silentAimEnabled = false
local silentAimConnection

local function toggleSilentAim(value)
    silentAimEnabled = value
    if silentAimEnabled then
        silentAimConnection = RunService.RenderStepped:Connect(function()
            local target = getClosestPlayerInFOV()
            if target and target.Character and target.Character:FindFirstChild(aimbotTargetPart) then
                local tool = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
                if tool then
                    local handle = tool:FindFirstChild("Handle")
                    if handle then
                        handle.CFrame = CFrame.new(handle.Position, target.Character[aimbotTargetPart].Position)
                    end
                end
            end
        end)
        myNotify({
            Title = "Silent Aim",
            Content = "Silent Aim enabled!",
            Duration = 3,
            Image = 13047715178
        })
    else
        if silentAimConnection then
            silentAimConnection:Disconnect()
            silentAimConnection = nil
        end
        myNotify({
            Title = "Silent Aim",
            Content = "Silent Aim disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

local hitboxExpanderEnabled = false
local hitboxSize = 5
local hitboxTransparency = 0.5

local function toggleHitboxExpander(value)
    hitboxExpanderEnabled = value
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local root = player.Character.HumanoidRootPart
            root.Size = value and Vector3.new(hitboxSize, hitboxSize, hitboxSize) or Vector3.new(2, 2, 1)
            root.Transparency = value and hitboxTransparency or 0
            root.CanCollide = false
        end
    end
    myNotify({
        Title = "Hitbox Expander",
        Content = "Hitbox Expander " .. (value and "enabled!" or "disabled!"),
        Duration = 3,
        Image = 13047715178
    })
end

local rapidFireEnabled = false

local function toggleRapidFire(value)
    rapidFireEnabled = value
    if value then
        RunService:BindToRenderStep("RapidFire", Enum.RenderPriority.Input.Value, function()
            local tool = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
            if tool and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
                tool:Activate()
            end
        end)
        myNotify({
            Title = "Rapid Fire",
            Content = "Rapid Fire enabled!",
            Duration = 3,
            Image = 13047715178
        })
    else
        RunService:UnbindFromRenderStep("RapidFire")
        myNotify({
            Title = "Rapid Fire",
            Content = "Rapid Fire disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

-- Combat Toggles and Options
local AimbotToggle = CombatTab:CreateToggle({
   Name = "Enable Aimbot",
   CurrentValue = false,
   Flag = "aimbotenable",
   Callback = function(Value)
       toggleAimbot(Value)
   end,
})

local TargetPartDropdown = CombatTab:CreateDropdown({
   Name = "Target Part",
   Options = {"Head", "HumanoidRootPart", "Torso"},
   CurrentOption = {"Head"},
   MultipleOptions = false,
   Flag = "targetpart",
   Callback = function(Option)
       aimbotTargetPart = Option[1]
   end,
})

local FOVSlider = CombatTab:CreateSlider({
   Name = "FOV Size",
   Range = {0, 500},
   Increment = 10,
   Suffix = "Radius",
   CurrentValue = 200,
   Flag = "fovsize",
   Callback = function(Value)
       aimbotFOV = Value
   end,
})

local SmoothnessSlider = CombatTab:CreateSlider({
   Name = "Smoothness",
   Range = {0, 1},
   Increment = 0.1,
   Suffix = "Factor",
   CurrentValue = 0.5,
   Flag = "smoothness",
   Callback = function(Value)
       aimbotSmoothness = Value
   end,
})

local VisibleCheckToggle = CombatTab:CreateToggle({
   Name = "Visible Check",
   CurrentValue = false,
   Flag = "visiblecheck",
   Callback = function(Value)
       aimbotVisibleCheck = Value
   end,
})

local AimbotTeamFilterToggle = CombatTab:CreateToggle({
   Name = "Team Filter",
   CurrentValue = false,
   Flag = "aimbotteamfilter",
   Callback = function(Value)
       aimbotTeamFilter = Value
   end,
})

local ShowFOVToggle = CombatTab:CreateToggle({
   Name = "Show FOV Circle",
   CurrentValue = false,
   Flag = "showfov",
   Callback = function(Value)
       showFOV = Value
   end,
})

local FOVColorPicker = CombatTab:CreateColorPicker({
   Name = "FOV Color",
   Color = Color3.fromRGB(255, 0, 0),
   Flag = "fovcolor",
   Callback = function(Color)
       fovColor = Color
   end
})

local TriggerbotToggle = CombatTab:CreateToggle({
   Name = "Triggerbot",
   CurrentValue = false,
   Flag = "triggerbot",
   Callback = function(Value)
       toggleTriggerbot(Value)
   end,
})

local AutoHeadshotToggle = CombatTab:CreateToggle({
   Name = "Auto Headshot",
   CurrentValue = false,
   Flag = "autoheadshot",
   Callback = function(Value)
       toggleAutoHeadshot(Value)
   end,
})

local SilentAimToggle = CombatTab:CreateToggle({
   Name = "Silent Aim",
   CurrentValue = false,
   Flag = "silentaim",
   Callback = function(Value)
       toggleSilentAim(Value)
   end,
})

local HitboxExpanderToggle = CombatTab:CreateToggle({
   Name = "Hitbox Expander",
   CurrentValue = false,
   Flag = "hitboxexpander",
   Callback = function(Value)
       toggleHitboxExpander(Value)
   end,
})

local HitboxSizeSlider = CombatTab:CreateSlider({
   Name = "Hitbox Size",
   Range = {1, 20},
   Increment = 1,
   Suffix = "Size",
   CurrentValue = 5,
   Flag = "hitboxsize",
   Callback = function(Value)
       hitboxSize = Value
       if hitboxExpanderEnabled then
           toggleHitboxExpander(false)
           toggleHitboxExpander(true)
       end
   end,
})

local HitboxTransparencySlider = CombatTab:CreateSlider({
   Name = "Hitbox Transparency",
   Range = {0, 1},
   Increment = 0.1,
   Suffix = "Transparency",
   CurrentValue = 0.5,
   Flag = "hitboxtrans",
   Callback = function(Value)
       hitboxTransparency = Value
       if hitboxExpanderEnabled then
           toggleHitboxExpander(false)
           toggleHitboxExpander(true)
       end
   end,
})

local RapidFireToggle = CombatTab:CreateToggle({
   Name = "Rapid Fire",
   CurrentValue = false,
   Flag = "rapidfire",
   Callback = function(Value)
       toggleRapidFire(Value)
   end,
})

local KillAllButton = CombatTab:CreateButton({
   Name = "Kill All",
   Callback = function()
       killAll()
   end,
})

-- Exploits Tab
local ExploitsTab = Window:CreateTab("💥 Exploits", nil)
local ExploitsSection = ExploitsTab:CreateSection("Options")

local infiniteAmmoEnabled = false
local noRecoilEnabled = false
local noSpreadEnabled = false
local godModeEnabled = false
local antiAFKEnabled = false

local function toggleInfiniteAmmo(value)
    infiniteAmmoEnabled = value
    if value then
        RunService:BindToRenderStep("InfiniteAmmo", Enum.RenderPriority.Character.Value, function()
            local tool = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
            if tool then
                for _, v in pairs(tool:GetDescendants()) do
                    if v:IsA("IntValue") and v.Name:lower():match("ammo") then
                        v.Value = math.huge
                    end
                end
            end
        end)
        myNotify({
            Title = "Infinite Ammo",
            Content = "Infinite Ammo enabled!",
            Duration = 3,
            Image = 13047715178
        })
    else
        RunService:UnbindFromRenderStep("InfiniteAmmo")
        myNotify({
            Title = "Infinite Ammo",
            Content = "Infinite Ammo disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

local function toggleNoRecoil(value)
    noRecoilEnabled = value
    if value then
        RunService:BindToRenderStep("NoRecoil", Enum.RenderPriority.Camera.Value, function()
            local tool = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
            if tool then
                for _, v in pairs(tool:GetDescendants()) do
                    if v:IsA("Vector3Value") and v.Name:lower():match("recoil") then
                        v.Value = Vector3.new(0, 0, 0)
                    end
                end
            end
        end)
        myNotify({
            Title = "No Recoil",
            Content = "No Recoil enabled!",
            Duration = 3,
            Image = 13047715178
        })
    else
        RunService:UnbindFromRenderStep("NoRecoil")
        myNotify({
            Title = "No Recoil",
            Content = "No Recoil disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

local function toggleNoSpread(value)
    noSpreadEnabled = value
    if value then
        RunService:BindToRenderStep("NoSpread", Enum.RenderPriority.Character.Value, function()
            local tool = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
            if tool then
                for _, v in pairs(tool:GetDescendants()) do
                    if v:IsA("NumberValue") and v.Name:lower():match("spread") then
                        v.Value = 0
                    end
                end
            end
        end)
        myNotify({
            Title = "No Spread",
            Content = "No Spread enabled!",
            Duration = 3,
            Image = 13047715178
        })
    else
        RunService:UnbindFromRenderStep("NoSpread")
        myNotify({
            Title = "No Spread",
            Content = "No Spread disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

local function toggleGodMode(value)
    godModeEnabled = value
    if value then
        RunService:BindToRenderStep("GodMode", Enum.RenderPriority.Character.Value, function()
            local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.Health = humanoid.MaxHealth
            end
        end)
        myNotify({
            Title = "God Mode",
            Content = "God Mode enabled!",
            Duration = 3,
            Image = 13047715178
        })
    else
        RunService:UnbindFromRenderStep("GodMode")
        myNotify({
            Title = "God Mode",
            Content = "God Mode disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

local function toggleAntiAFK(value)
    antiAFKEnabled = value
    if value then
        Players.LocalPlayer.Idled:Connect(function()
            if antiAFKEnabled then
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end
        end)
        myNotify({
            Title = "Anti-AFK",
            Content = "Anti-AFK enabled!",
            Duration = 3,
            Image = 13047715178
        })
    else
        myNotify({
            Title = "Anti-AFK",
            Content = "Anti-AFK disabled!",
            Duration = 3,
            Image = 13047715178
        })
    end
end

local function giveItem(itemName)
    for _, v in pairs(ReplicatedStorage:GetDescendants()) do
        if v:IsA("RemoteEvent") and (v.Name:lower():match("give") or v.Name:lower():match("equip")) then
            pcall(function()
                v:FireServer(itemName)
            end)
        end
    end
    myNotify({
        Title = "Give Item",
        Content = "Attempted to give item: " .. itemName,
        Duration = 3,
        Image = 13047715178
    })
end

local function serverCrash()
    local crashPayload = {}
    for i = 1, 500 do
        table.insert(crashPayload, string.rep(tostring(math.huge), 100))
    end
    for _, v in pairs(ReplicatedStorage:GetDescendants()) do
        if v:IsA("RemoteEvent") then
            for i = 1, 50 do
                pcall(function()
                    v:FireServer(crashPayload, math.huge, nil, {})
                end)
            end
        end
    end
    myNotify({
        Title = "Server Crash",
        Content = "Server crash attempt completed!",
        Duration = 3,
        Image = 13047715178
    })
end

local InfiniteAmmoToggle = ExploitsTab:CreateToggle({
   Name = "Infinite Ammo",
   CurrentValue = false,
   Flag = "infiniteammo",
   Callback = function(Value)
       toggleInfiniteAmmo(Value)
   end,
})

local NoRecoilToggle = ExploitsTab:CreateToggle({
   Name = "No Recoil",
   CurrentValue = false,
   Flag = "norecoil",
   Callback = function(Value)
       toggleNoRecoil(Value)
   end,
})

local NoSpreadToggle = ExploitsTab:CreateToggle({
   Name = "No Spread",
   CurrentValue = false,
   Flag = "nospread",
   Callback = function(Value)
       toggleNoSpread(Value)
   end,
})

local GodModeToggle = ExploitsTab:CreateToggle({
   Name = "God Mode",
   CurrentValue = false,
   Flag = "godmode",
   Callback = function(Value)
       toggleGodMode(Value)
   end,
})

local AntiAFKToggle = ExploitsTab:CreateToggle({
   Name = "Anti-AFK",
   CurrentValue = false,
   Flag = "antiafk",
   Callback = function(Value)
       toggleAntiAFK(Value)
   end,
})

local GiveItemInput = ExploitsTab:CreateInput({
   Name = "Give Item",
   PlaceholderText = "Enter item name",
   RemoveTextAfterFocusLost = true,
   Callback = function(Text)
       giveItem(Text)
   end,
})

local ServerCrashButton = ExploitsTab:CreateButton({
   Name = "Server Crash (WARNING)",
   Callback = function()
       myNotify({
           Title = "Server Crash",
           Content = "Attempting to crash server... Use with caution!",
           Duration = 3,
           Image = 13047715178
       })
       serverCrash()
   end,
})

local ServerHopButton = ExploitsTab:CreateButton({
   Name = "Server Hop",
   Callback = function()
       local servers = HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"))
       local serverId = servers.data[math.random(1, #servers.data)].id
       TeleportService:TeleportToPlaceInstance(game.PlaceId, serverId)
       myNotify({
           Title = "Server Hop",
           Content = "Hopping to a new server...",
           Duration = 3,
           Image = 13047715178
       })
   end,
})

-- Settings Tab
local SettingsTab = Window:CreateTab("⚙️ Settings", nil)
local SettingsSection = SettingsTab:CreateSection("Options")

local FlyKeybind = SettingsTab:CreateKeybind({
   Name = "Fly Keybind",
   CurrentKeybind = "F",
   Flag = "flykeybind",
   Callback = function(Key)
       keybinds.fly = Enum.KeyCode[Key]
   end,
})

local NoclipKeybind = SettingsTab:CreateKeybind({
   Name = "Noclip Keybind",
   CurrentKeybind = "G",
   Flag = "noclipkeybind",
   Callback = function(Key)
       keybinds.noclip = Enum.KeyCode[Key]
   end,
})

local InteractKeybind = SettingsTab:CreateKeybind({
   Name = "Interact Keybind",
   CurrentKeybind = "E",
   Flag = "interactkeybind",
   Callback = function(Key)
       keybinds.interact = Enum.KeyCode[Key]
   end,
})

local InteractDistanceSlider = SettingsTab:CreateSlider({
   Name = "Interact Distance",
   Range = {5, 50},
   Increment = 1,
   Suffix = "Studs",
   CurrentValue = 10,
   Flag = "interactdistance",
   Callback = function(Value)
       interactDistance = Value
   end,
})

local InteractHighlightColorPicker = SettingsTab:CreateColorPicker({
   Name = "Interact Highlight Color",
   Color = Color3.fromRGB(255, 255, 0),
   Flag = "interacthighlightcolor",
   Callback = function(Color)
       interactHighlightColor = Color
       for _, highlight in pairs(interactableParts) do
           highlight.FillColor = Color
           highlight.OutlineColor = Color
       end
   end
})

local FPSUnlockerToggle = SettingsTab:CreateToggle({
   Name = "FPS Unlocker",
   CurrentValue = false,
   Flag = "fpsunlocker",
   Callback = function(Value)
       if Value then
           setfpscap(999)
       else
           setfpscap(60)
       end
       myNotify({
           Title = "FPS Unlocker",
           Content = "FPS Unlocker " .. (Value and "enabled!" or "disabled!"),
           Duration = 3,
           Image = 13047715178
       })
   end,
